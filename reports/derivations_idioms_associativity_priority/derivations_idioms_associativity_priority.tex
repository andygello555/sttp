\documentclass[12pt, letterpaper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{cprotect}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage[linguistics]{forest}
\usepackage{float}
\usepackage{array}
\usepackage{hyperref}

% Metadata
\title{The use derivation rules, and grammar idioms to capture notions of associativity and priority in arithmetic expressions}

\author{Jakab Zeller}

\date{October 2021}

% Environments
\newenvironment{tightcenter}{%
  \setlength\topsep{0pt}
  \setlength\parskip{0pt}
  \begin{center}
}{%
  \end{center}
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]

\begin{document}

\maketitle

\section{Associativity}

Formally, a binary operation $\star$, is associative if the \textbf{associative property} will hold for all $x$, $y$, and $z$.

\begin{figure}[H]
    \begin{equation}
        (x \star y) \star z = x \star (y \star z)
        \nonumber
    \end{equation}
    \caption{The associative property}
\end{figure}

Informally the associative property says that any given expression which uses solely associative binary operators can have any number of parentheses within it. The result will not be any different if all parentheses were removed/rearranged. Examples of associative binary operations include:

\begin{enumerate}
    \item String concatentation
    \item Addition of complex and real numbers
    \item Multiplication of complex and real numbers
\end{enumerate}

Non-associative operations are ones that do not hold the associative property. Such as...

\begin{enumerate}
    \item Subtraction
    \item Division
    \item Exponentiation
\end{enumerate}

Conventionally, we have derived notions to evaluate expressions containing non-associative operations without parentheses. This is done by deciding on an order to carry out said operations. There two notational conventions for this:

\begin{itemize}
    \item \textbf{Left-associative} operators are conventionally evaluated from left to right. This is the case for \textbf{subtraction} and \textbf{division}.
    \begin{equation}
        \begin{split}
            x - y - z &= (x - y) - z\\
            x / y / z &= (x / y) / z
        \end{split}
        \nonumber
    \end{equation}
    \item \textbf{Right-associative} operators are conventionally evaluated from right to left. This is the case for \textbf{exponentiation}.
    \begin{equation}
        x^{y^z} = x^{(y^z)}
        \nonumber
    \end{equation}
\end{itemize}

\subsection{Grammars}

In programming language grammars expressions and operators contained within these expressions tend to follow the formal rules of associativity as defined in mathematics. This means programming language designers need to take into account these rules whilst designing grammars in order to not alienate users.

To `encode' associativity within a grammar you need to make sure that the production rules for the operators are left or right recursive depending on whether the operator is left or right associative. For example, the grammar below defines an exponent operator (\verb|**|) with right associativity and an addition operator (\verb|+|) with left associativity.

\textit{Note that the grammar also gives the exponent operator higher precedence than the addition operator. This will be explained later on in the \hyperref[sec:priority]{priority section}}

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
                        E ::= T | E "+" T
                        T ::= F | F "**" T
                        F ::= Num | "(" E ")"
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \caption{Simple example showing how to encode left and right associativity within a grammar}
\end{figure}

A production rule in the form $\gamma \rightarrow \alpha \gamma$ means that the non-terminal $\gamma$ is right recursive, whereas a production rule in the form $\gamma \rightarrow \gamma \alpha$ means that the non-terminal $\gamma$ is left recursive. In practice, this means that the either the left or the right hand rule will be expanded and evaluated which encodes the precedence of the operator.

\subsection{Coping with parser generators}

\subsubsection{Parser generators which do not accept grammars with left recursion}

The grammar given in fig. 2 contains left recursion so a generated LL(1) or recursive descent parser will not terminate. This means that recursive descent and LL(1) parser cannot be generated if you wanted to parse a language with left associative operators.

\begin{center}
    \textbf{How do you get around this?}
\end{center}

One of the easiest ways to encode left associative operators within a grammar is to use \textbf{iteration rather than recursion}. Many parser generators, such as ANTLR, support the `\verb|*|' or `\verb|{ ... }|' iteration/repetition operators (supported by EBNF) to define a string of terminals/non-terminals that can be repeated zero or many times. Rewriting the grammar shown in fig. 2 using the `\verb|{ ... }|' EBNF operator to remove left recursion would result in the following grammar.

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
                        E ::= T { "+" T }
                        T ::= F [ "**" T ]
                        F ::= Num | "(" E ")"
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \caption{The grammar in fig. 2 rewritten with the EBNF to remove left recursion}
\end{figure}

An LL(1) or recursive descent parser generator might produce the following code for the non-terminal \verb|E|.

\pagebreak

\begin{verbatim}
    function E() {
        T();
        while (x == "+") {
            x == gnt();
            T();
        }
    }
\end{verbatim}

\textit{It must be noted that in the example the following assumptions are made...}

\begin{itemize}
    \item \textit{Error handling has been omitted}
    \item \verb|x| \textit{is a global variable containing the current token}
    \item \verb|gnt()| \textit{consumes and returns the next token}
\end{itemize}

In terms of the parse tree this will create a child for each repetition that is found in the input string. For example, for the given input string: \verb|1 + 2 + 3 ** 4|, the following derivation tree is created.

\begin{center}
    \begin{forest}
        for tree={
            if n children=0{
                font=\itshape,
            }{},
            }
            [$E$
                [$T$
                    [$F$
                        [Num: $1$]
                    ]
                ]
                [$+$]
                [$T$
                    [$F$
                        [Num: $2$]
                    ]
                ]
                [$+$]
                [$T$
                    [$F$
                        [Num: $3$]
                    ]
                    [{$**$}]
                    [$T$
                        [$F$
                            [Num: $4$]
                        ]
                    ]
                ]
            ]
    \end{forest}
\end{center}

As you can see this results in a fairly `unintuitive' parse tree that can benefit from some restructuring. This can be done on the fly in some parser generators as explained in the next section.

\subsubsection{Modifying the parse tree on the fly}

Some parser generators such as rdp allow you to modify the parse tree on the fly using what are called \textbf{promotion operators}. These operators allow you to promote any terminal/non-terminal to above, below or under its parent node in the parse tree. This allows you to construct parts of the tree in a somewhat bottom-up manner.

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
                    E ::= T^^ { "+"^^^ T }
                    T ::= F [ "**"^^ T ]:^^
                    F ::= Num^^ | "("^ E^^ ")"^
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \caption{The grammar in fig. 3 rewritten to use promotion operators}
\end{figure}

\begin{center}
    \textbf{Here are the semantics behind the promotion operators:}
    \begin{itemize}
        \item \verb|^|: \textbf{Promote underneath parent} - the node is promoted to the parent and is also overwritten by its parent node. This effectively discards the promoted node.
        \item \verb|^^|: \textbf{Promote on top of parent} - the node is promoted to the parent node and overwrites the parents node.
        \item \verb|^^^|: \textbf{Promote above parent} - the node is promoted to the parent of the parent node and overwrites it.
    \end{itemize}
\end{center}

Looking back at the grammar there are a couple of takeaways before discussing an input string.

\begin{enumerate}
    \item The \textbf{parentheses are obfuscated using the promote underneath operator} (\verb|^|). This is because semantically, parentheses are not required for the evaluation of a arithmetic expression.
    \item \verb|:^^| promotes $\epsilon$ to on top of its parent.
\end{enumerate}


\begin{center}
    Here is the parse tree for the input string: \verb|1 + 2 + 3 + (4 + 5 ** 6)|.
    \begin{forest}
        for tree={
            if n children=0{
                font=\itshape,
            }{},
            }
            [$+$
                [$+$
                    [$+$
                        [Num: $1$]
                        [Num: $2$]
                    ]
                    [Num: $3$]
                ]
                [$+$
                    [Num: $4$]
                    [$**$
                        [Num: $5$]
                        [Num: $6$]
                    ]
                ]
            ]
    \end{forest}
\end{center}

As you can see this updated grammar produces a more conventional arithmetic tree which can be traversed in pre, post and infix orders, depending on requirement.

\section{Priority}
\label{sec:priority}

% Bibliography
% http://www.cs.rhul.ac.uk/research/languages/publications/rdp_user.pdf
% http://www.cs.ecu.edu/karl/5220/spr16/Notes/CFG/precedence.html
% https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form

\end{document}