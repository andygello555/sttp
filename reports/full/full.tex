\immediate\write18{texcount -1 -q -relaxed -sum -merge \jobname.tex -out=\jobname.sum}
\documentclass[]{full}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{caption}
\usepackage{import}
\usepackage[style=ieee]{biblatex}
\usepackage[table,xcdraw]{xcolor}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pmboxdraw}
\usepackage{verbatim} % for verbatim environment and \verbatiminput
% \usepackage{sverb} % for \verbinput
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}
\newcommand\wordcount{\inputminted[firstline=1, lastline=1, fontfamily=helvetica]{text}{\jobname.sum}}

% \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
% \AfterEndEnvironment{minted}{\end{tcolorbox}}%

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2022}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: \wordcount ($text + headings + captions + equations$)

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 2022

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Motivations}
\label{chap:motivations}

Web APIs are in the background of most applications and services we use. Everything from requesting the weather in a certain country, accessing up to date exchange rate information, to accessing personal calendar information, can all be achieved through the use of specific web APIs.

\textit{A server side web API is an application programming interface that is hosted on a web server accessible via the HTTP protocol. Endpoints within a web API specify where an action or resource lies, creating a \textbf{directory like structure} of `methods'.}

The number of web APIs has risen substantially over the last decade and a half. \href{https://www.programmableweb.com/category/all/apis}{ProgrammableWeb}, cites over 24,000 APIs (as of January 2022). A large increase from 2013: 9000, and an even larger increase from 2005: 105\textsuperscript{\cite{duvander_2013}}.

\textit{Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites\textsuperscript{\cite{web_scraping_wikipedia_2022}}.}

Partly due to the ubiquity of web APIs, as well as my interest toward creating autonomous web-scraping solutions. I have gained a lot of experience using them, and have even developed a few of my own. Before beginning this project, I had been working on a large library of web scraping procedures, to track, scrape, and store information on several hundreds of applications on the popular PC video game e-tailer: \href{https://store.steampowered.com/}{Steam}. This was largely achieved by using Steam's Web API, but also by scraping data directly from webpages, dashboards, and portals. The data retrieved by said procedures would be stored in a database, accessible via a web API. Most of the endpoints within this API perform various complex manipulations and aggregations to return a representation of the data that is easier to handle for users. This interest soon stemmed into my professional life, when I was asked to implement this system on a larger scale for a indie video game publisher. Thus increasing the workload and data throughput of the server.

Soon, the complexity of the codebase spiralled out of control. The test suites that were written to check if the procedures were functioning properly, became large and unruly. Frequent and undocumented changes to the Steam Web API, would render some procedures out of action for several days. To deal with this issue, I moved the implementation of some of the test suites to \href{https://insomnia.rest/}{Insomnia} (a REST client that allows you to build test suites for web APIs). Whilst having an extensive feature-set for a REST client, Insomnia lacked control-flow constructs for complex request and response handling. Constructs such as conditionals, looping, and error handling, are missing/very hard to implement. Soon after, the tests written in Insomnia were abandoned in favour of refactored versions of the previous tests within the code base itself.

Due to this need of greater functionality, I propose a scripting language purposefully designed as a HTTP client and test suite first.

\begin{center}
\verb|sttp| \textit{(amalgamation of `scripting' and `HTTP')}
\end{center}

\verb|sttp| was made in order to test web APIs that have complex interaction flows, or APIs that are just black boxes. The main features that \verb|sttp| was designed in mind with are:

\begin{enumerate}
    \item \textbf{Builtin HTTP client}. There must be a way to make HTTP requests.
    \item \textbf{Concise, quick and manageable builtin testing}. Tests should be easily implementable and modifiable. There should also be a way of grouping tests for actions that access a similar resource. Just like how REST APIs are designed.
    \item \textbf{JSON values and JSONPath}. All values in \verb|sttp| should be parsable to JSON and back. As most web APIs default to JSON as their interchange format, it makes sense to treat all data as JSON. \textbf{JSONPath}, is a syntax for accessing JSON values in the similar vain of XPath for XML\textsuperscript{\cite{goessner_2007}}.
    \item \textbf{Executing HTTP requests concurrently}. Concurrency should be easy and encouraged.
    \item \textbf{Command line usage}. I regularly tinker and test endpoints on the command line. Thus I expect the \verb|sttp| interpreter to be able to be run from the command line. This means creating a \textbf{whitespace independent grammar} that allows for input to be typed on a single line.
    \item \textbf{Web scraping functionality}. Such as a HTML parser, tree search functions, and filtering.
\end{enumerate}

To achieve this, I decided to write an interpreter using Go\textsuperscript{\cite{the_go_programming_language}} and the participle parser generator\textsuperscript{\cite{thomas_2021}}. I chose Go as its accompanying toolset allows for quick testing and benchmarking. I knew this would be useful when developing the language and benchmarking the concurrency constructs within the language. This native tooling also allows for rapid development and less external dependencies. At the beginning of the project I was comfortable at writing code in Go, as I had used it for numerous other projects in the past.

I chose the participle parser generator, as it was (and still is) being actively developed, and had a plethora of examples available. It also has an interesting way of defining the accepted grammar for the generated parser. Encoding EBNF within the AST node type declarations, the instantiated versions of which will be returned by the generated parser (explained further whilst discussing the \hyperref[sec:four-function-calc]{four-function calculator}). However, the generated parsers are recursive descent parsers. This meant I had to design my language without any left-recursion. Thankfully, the iteration operator in participle's EBNF notation, solved some of the issues, such as left-associative operators.

\section{The Future}

As explained in the \hyperref[chap:motivations]{motivations introduction}, much of my professional life and pastimes involve creating and testing web APIs. Therefore, \verb|sttp| is something that I would hope to use in both domains. I plan on continuing development on \verb|sttp| in the background to add newer features that will solve issues that occur frequently in my work life. Go is also rising in popularity within the web API space, and now that I am fairly fluent in it, I hope to use it within the workplace soon.

As I enjoyed learning the theory behind programming language design and engineering as much as I enjoyed creating \verb|sttp|. I hope I can make better use of this knowledge in the appropriate field of work. I have found the material covered within \textit{CS3480: Software Language Engineering}, quite eye-opening as to the number of different Domain Specific Languages (DSL), in use and in development. There is a DSL for everything from CAD 3D modelling to programming robots\textsuperscript{\cite{nordmann_hochgeschwender_wrede_2014}}. A job within this area could have work that I find rewarding and interesting.

\chapter{How to read this report}

This report is split into two broad parts. The first reads as a quick introduction to web-APIs and how to use them, as well as how the \verb|sttp| programming language fits into this space. It also includes examples and explanations of how to program in \verb|sttp|, and outlines the problems that it solves. The second, reads as an in-depth technical overview of \verb|sttp|'s development with specific details on the data-structures and algorithms used. This section will dive into specific source-code listings within the interpreter, and it assumes an intermediate knowledge of programming in Go.

The reason behind this split was so that readers can get a reasonable understanding of how \verb|sttp| might work internally, through the real-world problems that it solves. It also enables those with more general expertise in computer science to get to grips with \verb|sttp| quicker.

\section{Specification}

The specification for \verb|sttp| can be found in \verb|documents/specification_for_language.pdf|. This is to be read as a more in-depth user guide to \verb|sttp|. Throughout the report this specification might referenced, in which case it can be used to supplement the material within the report.

\section{Submission directory structure}

The below directory structure shows the directories within my submission.

\begin{verbatim}
IndividualProject_2021_Jakab.Zeller
├── documents - PDF versions of the reports found in reports/
├── reports - Reports written towards my final project
│   ├── context_free_grammars_and_manual_procedures - 1st report on theory,
│   │                                                 which forms part of
│   │                                                 my interim report
│   ├── derivations_idioms_associativity_priority - 2nd report on theory,
│   │                                               which forms part of
│   │                                               my interim report
│   ├── full - This report
│   │   └── blog_api
│   │       ├── blog_api_server - The REST API server used in part 1
│   │       └── blog_api_tests - The sttp test suite for the above server
│   │           ├── 01_topics
│   │           ├── 02_blogs
│   │           ├── 03_comments
│   │           └── 04_cleanup
│   ├── interim - Interim report
│   └── specification_for_language - The specification for sttp
├── src - The source code for sttp
│   ├── _examples - The examples used to test sttp (included within the
│   │   │           appendix of this report)
│   │   ├── echo_chamber - The echo chamber web API used during testing
│   │   │                  (copy from test_programs/test-web-api/)
│   │   ├── example_01
│   │   ├── example_02
│   │   ├── example_03
│   │   ├── example_04
│   │   ├── example_05
│   │   ├── example_06
│   │   ├── example_07
│   │   ├── example_08
│   │   ├── example_09
│   │   ├── example_10
│   │   ├── example_11
│   │   ├── example_12
│   │   ├── example_13
│   │   ├── example_14
│   │   ├── example_15
│   │   └── test_suites - Examples for testing test suites
│   │       ├── example_01
│   │       └── example_02
│   ├── data
│   ├── errors
│   ├── eval
│   └── parser
└── test_programs - The test programs written towards my final project
    ├── four_func_calc - A four-function calculator
    ├── test-web-api - The echo chamber web API used to test sttp
    └── thompsons - The regex minimiser
\end{verbatim}

\cprotect\part{Meet \verb|sttp|}

\import{chapters}{3-web-apis.tex}

\import{chapters}{4-designing-rest-api.tex}

\import{chapters}{5-hello-sttp.tex}

\part{Technical}

To fully understand the technical information within this part, it is recommended that you first read through the sections on test programs. These will run through the functionality utilised by the participle parser generator library, as well as some of the general feature-set of Go that is heavily utilised in the \verb|sttp| interpreter.

\chapter{Test Programs}
\label{chap:test-programs}

\import{sections}{2-1-four-func-calc.tex}

\import{sections}{2-2-regex-minimiser.tex}

\chapter{Development}
\label{chap:development}

\import{sections}{2-3-grammar-ast.tex}

\import{sections}{2-4-data-structures.tex}

\import{sections}{2-5-casting.tex}

\import{sections}{2-6-operators.tex}

\section{Evaluating AST nodes}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``Made final touches to interim report before handing in. Completed all operator actions as well as defining agnostic evaluation methods for all precedence levels. I also implemented assignment statements as well as if-elif-else statements. Along with JSONPath setting and getting. I had to rewrite my Heap data structure and my Value structure."}\\[0.5em]
        \tiny{11:51 am on December 6, 2021}
    \end{center}
\end{figure}
    
Each AST node within \verb|sttp| implements the \verb|evalNode| interface. This defines the \mintinline[breaklines]{go}{Eval(vm VM) (err error, result *data.Value)} instance method (among other things), that will be called on the root AST node (\verb|Program|) with a fresh \verb|VM| instance. The \verb|Eval| instance method of each lower AST node will be called as the interpreter executes a depth-first leftmost tree traversal; passing the \verb|VM| instance to each. The \verb|err| return parameter is used to `bubble' up an error/exception if one occurs in any of the AST nodes. This error will either float up to the \verb|Program| root, or to a \verb|TryCatch| AST node. The \verb|evalNode| interface was mainly implemented to improve readability and reduce complexity with the evaluation of AST nodes within \hyperref[sec:development-ast-nodes-expressions]{expression subtrees}.

Most AST node will be given a section for technical explanation below in the order that they were \textbf{first} implemented. Not all AST nodes warrant a complete technical breakdown. This is done for AST node's that have a fairly straightforward implementation, or do not warrant discussion. In these cases a reference to the appropriate file and line numbers in the code will be provided so that the code can be inspected easily.

% \import{sections}{2-7-1-jsonpath-assignment.tex}
\subsection{JSONPath and Assignment}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-2]}{\verb|src/_examples/example_02/example_02.sttp|}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: json path setter + assignment ast node
- Added beginnings of json path setters and getters (02/12/2021 - 12:30:37)
- Added some more eval referrers for different AST nodes (02/12/2021 - 12:31:03)
- Added the Current referrer to the CallStack interface which returns the topmost
  frame (02/12/2021 - 12:31:33)
- Added the Exception and JSONPathError RuntimeErrors (02/12/2021 - 12:31:55)
    \end{minted}
    \vspace{-1em}
    \tiny{December 2, 2021}
\end{center}
%TC:endignore

The \verb|src/parser/json_path.go| contains the \verb|Path| type that acts as an intermediate representation for JSONPath access and setting. Each segment of a JSONPath AST node has a correlated \verb|Convert| method which carries out this transformation. From there a \verb|Path| can be used to \verb|Get| and \verb|Set| values of the given value with the corresponding methods.

The \verb|Eval| method for the JSONPath AST node can be found in: \verb|src/parser/eval.go:863|, whereas the \verb|Eval| method for the Assignment AST node can be found at \verb|src/parser/eval.go:166|.

\import{sections}{2-7-2-expressions.tex}

% \import{sections}{2-7-3-if-elif-else.tex}
\subsection{If-Elif-Else}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-3]}{\verb|src/_examples/example_03/example_03.sttp|}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}[breaklines]{markdown}
Language: Heap rework + Symbol -> Value + IfElifElse
- Reworked Heap datastructure (06/12/2021 - 02:57:30)
- Renamed Symbol to Value (06/12/2021 - 02:57:54)
- Refactored a lot of files to accomodate these 
  changes (06/12/2021 - 02:58:14)
- Implemented ifelifelse Eval referrer and added example
  code to test it (06/12/2021 - 03:57:36)
    \end{minted}
    \vspace{-1em}
    \tiny{December 6, 2021}
\end{center}
%TC:endignore

The \verb|Eval| method for the \verb|IfElifElse| AST node can be found in: \verb|src/parser/eval.go:796|.

% \import{sections}{2-7-4-iterations.tex}
\subsection{Iteration}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: ReadOnly Values + Iterator + While, For, ForEach + examples
- Updated example_03 with some more 'advanced' if-elif-else 
  usage (06/12/2021 - 22:57:36)
- Added ReadOnly flag to Value struct (06/12/2021 - 22:58:04)
- Added ImutableValue error after adding ReadOnly flag (06/12/2021 - 22:58:39)
- Added logic for While, For, and ForEach loops (06/12/2021 - 22:59:01)
- Also added examples for each of these loops (06/12/2021 - 22:59:17)
- Added the Iterator type to the data package which uses the container/heap
  package to construct an iterator from a String, Object, or Array
  Type (06/12/2021 - 23:01:13)
- Removed some accidental printlns (06/12/2021 - 23:02:27)
    \end{minted}
    \vspace{-1em}
    \tiny{December 6, 2021}
\end{center}
%TC:endignore

There are three statements used for iteration within \verb|sttp|:

\begin{enumerate}
    \item \verb|While| (example found in \hyperref[appendix:sttp-examples-4]{here}): \verb|Eval| method can be found at: \verb|src/parser/eval.go:331|.
    \item \verb|For| (example found in \hyperref[appendix:sttp-examples-5]{here}): \verb|Eval| method can be found at: \verb|src/parser/eval.go:375|.
    \item \verb|ForEach| (example found in \hyperref[appendix:sttp-examples-6]{here}): \verb|Eval| method can be found at: \verb|src/parser/eval.go:434|.
\end{enumerate}

% \import{sections}{2-7-5-functions.tex}
\subsection{Functions}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-7]}{\verb|src/_examples/example_07/example_07.sttp|}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``This week I worked some more on adding in features to sttp. Since last week I have added all iteration structures (while, for, foreach), as well as function definitions and function calls which required quite a major rework to the stack. Currently the CallStack.Call method will copy over references to all global values to the new stack frame’s heap as well as creating a “self” variable that is filled with the value pointed to by the function definition’s root property. On top of this I also implemented the test statement and the TestSuite, which allows for the execution of directory-based sttp test suites."}\\[0.5em]
        \tiny{1:44 am on November 12, 2021}
    \end{center}
\end{figure}

There are two AST nodes surrounding the evaluation and definition of functions:

\begin{enumerate}
    \item \verb|FunctionDefinition|: \verb|Eval| method can be found at: \verb|src/parser/eval.go:643|.
    \item \verb|FunctionCall|: \verb|Eval| method can be found at: \verb|src/parser/eval.go:695|.
\end{enumerate}

% \import{sections}{2-7-6-http-methods.tex}
\subsection{HTTP Methods}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-9]}{\verb|src/_examples/example_09/example_09.sttp|}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: Method.Call setup + tests + Resty integration
- Chose the Resty library for internal HTTP method calls (12/12/2021 - 14:21:50)
- Moved Method enum to eval package and created MethodParamType to describe the
  accepted paramters for each HTTP method call (13/12/2021 - 17:12:19)
- Added Method.Call which calls the appropriate Resty functions and encapsulates
  the returned data within a data.Value (13/12/2021 - 17:13:01)
- Added a test for Method.Call. This was done by copying the echo chamber web
  server over to the _example folder (13/12/2021 - 17:14:04)
    \end{minted}
    \vspace{-1em}
    \tiny{December 13, 2021}
\end{center}
%TC:endignore

The \verb|MethodCall| AST node has a similar syntax to function calls but instead of having a user-defined function name it can only have one of the supported \verb|sttp| HTTP methods\textsuperscript{\cite{http_request_methods}}: \verb|GET|, \verb|HEAD|, \verb|POST|, \verb|PUT|, \verb|DELETE|, \verb|OPTIONS|, and \verb|PATCH|. The \verb|Eval| method for the \verb|MethodCall| can be found at: \verb|src/parser/eval.go:239|.

% \import{sections}{2-7-7-testing.tex}
\cprotect\subsection{Test suites and the \verb|test| statement}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: implementation of TestSuite capabilities + TestStatement
- Set up test data structures as well as interfaces (11/12/2021 - 02:50:34)
- TestStatement.Eval filled (11/12/2021 - 02:51:01)
- Methods for test datastructures (11/12/2021 - 02:51:14)
- Added TestSuite.Run + implemented TestStatement.Eval (12/12/2021 - 01:20:55)
- Added TestSuite testing capabilities (12/12/2021 - 01:21:14)
- Added an initial test suite test (12/12/2021 - 01:34:16)
- Created interfaces for TestResults so that they could be used within parser
  package (12/12/2021 - 01:34:50)
    \end{minted}
    \vspace{-1em}
    \tiny{December 12, 2021}
\end{center}
%TC:endignore

Test suites and \verb|test| statements are one of the most important features and motivations behind creating \verb|sttp|. They allow the programmer to construct test suites using a directory structure containing \verb|sttp| scripts. The practical usage of this can be found in the \hyperref[sec:hello-sttp-using-sttp-to-test]{first part} of this report.

The \verb|Eval| method for the \verb|TestStatement| node can be found at: \verb|src/parser/eval.go:294|, whereas the logic regarding test suite evaluation can be found within: \verb|src/test.go|.

% \import{sections}{2-7-8-try-catch-throw.tex}
\cprotect\subsection{Try-Catch and \verb|throw|}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-10]}{\verb|src/_examples/example_10/example_10.sttp|}

As well as returning a \verb|Value|, \verb|Eval| also can return an \mintinline[breaklines]{go}{error}. Each implementor of \verb|evalNode| will pass any errors that occur within that node, or from evaluating any lower down nodes, up to the parent node (the node that called the current node's \verb|Eval| method). This is true for all nodes apart from the \verb|TryCatch| node, which will instead wrap any error that occurs within its \verb|try| \verb|Block|, store it within the given identifier, then execute the \verb|Block| nested within the \verb|catch as| statement.

The \verb|TryCatch| node's \verb|Eval| can be found at: \verb|src/parser/eval.go:612|, whereas the error handling itself resides mostly within the \verb|src/errors/| package.

\import{sections}{2-7-9-batch-statement.tex}

% \import{sections}{2-7-10-builtins.tex}
\section{Builtins}
\label{sec:development-builtins}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: rearranging examples + builtin function call + testing
- Removed HTTP methods unsupported by Resty (13/12/2021 - 20:51:41)
- Made TestTestSuite_Run test more leniant in case ReadDir returns files in
  different order (13/12/2021 - 20:54:22)
- Implemented builtin functions on the FunctionCall.Eval end
  (13/12/2021 - 20:54:47)
- Added a builtins map and a function to access this map externally
  (13/12/2021 - 20:55:17)
- Added Stdout and Stderr fields to sttp VM as well as getters for these
  fields in the VM interface (13/12/2021 - 20:59:17)
- Also added stdout and stderr params to TestSuite.Run (13/12/2021 - 20:59:38)
- Restructuring main_test examples by moving them to individual directories
  with stdout, stderr and heap files (13/12/2021 - 21:00:50)
- Made Method.Call tests more stable by using only one cookie, as sometimes
  the cookie order is different in the response from the webserver
  (13/12/2021 - 21:55:06)
    \end{minted}
    \vspace{-1em}
    \tiny{December 13, 2021}
\end{center}
%TC:endignore

The number of builtin functions within \verb|sttp| at the time of writing is limited. This could be because many of the actions reserved for builtin functions in other languages, such as a length function, can be done through operators. All the builtins are stored within a lookup that is initialised at interpreter runtime within the \verb|src/parser/functions.go| file. These functions and their semantics are discussed further within the specification found in \verb|documents/specification_for_language.pdf|. Unlike \verb|MethodCall|s builtin functions utilise the same AST node as \verb|FunctionCall|s so are evaluated through the same \verb|Eval| method (found in \verb|src/parser/eval.go:695|).

\import{chapters}{7-evaluation.tex}

\import{chapters}{8-discussion.tex}

\import{chapters}{9-professional-issues.tex}

\appendix

%TC:ignore
\cprotect\chapter{\verb|sttp| Examples}
\label{appendix:sttp-examples}

\cprotect\textit{Located in: \verb|src/_examples/example_XX|}

\verb|sttp| examples that are run as unit tests for the \verb|sttp| interpreter. Please read the \verb|README| to find out how to build/run the \verb|sttp| interpreter from source. The expected stdout, stderr, test output, and error output will be located within the example's directory, \textbf{if it has an output available}.

\cprotect\textit{Note: some of these examples require the echo-chamber web API to be running alongside the \verb|sttp| interpreter. This can be found in \verb|src/_examples/echo_chamber/main.js|, and can be run using \verb|node main.js|.}

\section{Example 1 - Catch all}
\label{appendix:sttp-examples-1}

A general catch all example. It first showcases the valid value types within \verb|sttp| by defining an Object literal containing them. It then goes along to define a function that is a member of the Object defined previously. This function showcases parameter application within \verb|sttp|, as well as traditional \verb|for| loops and if statements. Then \verb|try-this-catch-as| and \verb|batch| statements are introduced by the way of a for-each loop and the \verb|throw| statement. \verb|sttp|'s whitespace independence is then showcased, with the \verb|test| statement introduction following it.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_01/example_01.sttp}

\section{Example 2 - JSONPath}
\label{appendix:sttp-examples-2}

This example showcases the ways of getting and setting values via JSONPath, as well as examples of how the sparse-fill technique used by \verb|sttp| works.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_02/example_02.sttp}

\section{Example 3 - IfElifElse}
\label{appendix:sttp-examples-3}

Showcases if-elif-else statements as well as testing the hanging else ambiguity that should be `fixed' using longest match.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_03/example_03.sttp}

\section{Example 4 - While}
\label{appendix:sttp-examples-4}

Showcasing while-loops as well as the \verb|break| statement within while-loops.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_04/example_04.sttp}

\section{Example 5 - For}
\label{appendix:sttp-examples-5}

A classic implementation of FizzBuzz using \verb|sttp|'s traditional for-loop. As with the example for while-loops, it also tests the behaviour of the \verb|break| statement.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_05/example_05.sttp}

\section{Example 6 - ForEach}
\label{appendix:sttp-examples-6}

Showcases the for-each-loop. This can have different behaviours when iterating over different values. The first loop showcases the behavior when iterating over Strings, the second: Arrays, the third: Objects, the fourth: literal values and the fifth: any other value.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_06/example_06.sttp}

\section{Example 7 - FunctionDefinition and FunctionCall}
\label{appendix:sttp-examples-7}

When I first implemented function definitions and invocation in \verb|sttp| I created this example to test certain tricky expected behaviours. For instance, the copying of Function values to other places, and the definition of functions within other functions.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_07/example_07.sttp}

\section{Example 8 - Recursive FunctionCalls}
\label{appendix:sttp-examples-8}

When implementing function invocation I was encountering a lot of bugs related to recursive function calls. I created this example to use as a test, and it involves defining two recursive functions to find the n\textsuperscript{th} Fibonacci number. The first definition is fairly standard implementation of this function, whereas the second makes use of the behaviours of function definition copying within \verb|sttp|.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_08/example_08.sttp}

\section{Example 9 - MethodCalls}
\label{appendix:sttp-examples-9}

Showcases all the available signatures for HTTP requests within \verb|sttp| by invoking each. The content from the responses of these requests is added to an Array.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_09/example_09.sttp}

\section{Example 10 - TryCatch}
\label{appendix:sttp-examples-10}

Showcases the \verb|try-this-catch-as| statement, as well as the \verb|throw| statement.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_10/example_10.sttp}

\section{Example 11 - Batch}
\label{appendix:sttp-examples-11}

Showcases the \verb|batch| statement as well as some of the edge cases that the interpreter will through an error for. This is discussed further in the \hyperref[chap:eval-ast-nodes-batch-edge-cases]{development} chapter. This example then goes on to test more peculiar edge cases such as batching recursive function calls that contain \verb|MethodCall|s.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_11/example_11.sttp}

\section{Example 12 - Free builtin}
\label{appendix:sttp-examples-12}

Showcases the \verb|free| builtin, which is used to `deallocate' variables from the current frame's heap. This makes use of the uncomputed \verb|Expression|s that are passed to each \verb|BuiltinFunction| instead of computed values.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_12/example_12.sttp}

\section{Example 13 - Find builtins}
\label{appendix:sttp-examples-13}

Showcases the find builtin functions: \verb|find|, \verb|find_all|, and \verb|find_all_parents|. These can be used for web scraping and this example illustrates the way they can be used to extract certain information from HTML that is parsed to an \verb|sttp| Object.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_13/example_13.sttp}

\section{Example 14 - Escape characters}
\label{appendix:sttp-examples-14}

This serves more as a test for escape characters within Strings than as an example.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_14/example_14.sttp}

\section{Example 15 - Breaking and returning}
\label{appendix:sttp-examples-15}

Used as a test for some edge cases I discovered that caused \verb|return| and \verb|break| statements within \verb|try-this-catch-as| statements to be caught as an error.

\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_15/example_15.sttp}
%TC:endignore

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}

\printbibheading
\printbibliography[keyword=cite,heading=subbibliography,title={Cited material}]%
\nocite{*}
\printbibliography[keyword=nocite,heading=subbibliography,title={Supplementary material}]

\end{document}

\end{article}
