\documentclass[]{full}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{caption}
\usepackage{import}
\usepackage[style=ieee]{biblatex}
\usepackage[table,xcdraw]{xcolor}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{mathtools}
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}

% \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
% \AfterEndEnvironment{minted}{\end{tcolorbox}}%

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2022}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count:

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 2022

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Motivations}
\label{chap:motivations}

\begin{definition}[Server side Web API]
    A server side web API is an application programming interface that is hosted on a web server accessible via the HTTP protocol. Endpoints within a web API specify where an action or resource lies, creating a \textbf{directory like structure} of `methods'.
\end{definition}

Web APIs are in the background of most applications and services we use. Everything from requesting the weather in a certain country, accessing up to date exchange rate information, to accessing personal calendar information, can all be achieved through the use of specific web APIs. The number of web APIs has risen substantially over the last decade and a half. \href{https://www.programmableweb.com/category/all/apis}{ProgrammableWeb}, cites over 24,000 APIs (as of January 2022). A large increase from 2013: 9000, and an even larger increase from 2005: 105\textsuperscript{\cite{duvander_2013}}.

\begin{definition}[Web Scraping]
    Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites\textsuperscript{\cite{web_scraping_wikipedia_2022}}.
\end{definition}

Partly due to the ubiquity of web APIs, as well as my interest toward creating autonomous web-scraping solutions. I have gained a lot of experience using them, and have even developed a few of my own. Before beginning this project, I had been working on a large library of web scraping procedures, to track, scrape, and store information on several hundreds of applications on the popular PC video game e-tailer: \href{https://store.steampowered.com/}{Steam}. This was largely achieved by using Steam's Web API, but also by scraping data directly from webpages, dashboards, and portals. The data retrieved by said procedures would be stored in a database, accessible via a web API. Most of the endpoints within this API perform various complex manipulations and aggregations to return a representation of the data that is easier to handle for users. This interest soon stemmed into my professional life, when I was asked to implement this system on a larger scale for a indie video game publisher. Thus increasing the workload and data throughput of the server.

Soon, the complexity of the codebase spiralled out of control. The test suites that were written to check if the procedures were functioning properly, became large and unruly. Frequent and undocumented changes to the Steam Web API, would render some procedures out of action for several days. To deal with this issue, I moved the implementation of some of the test suites to \href{https://insomnia.rest/}{Insomnia} (a REST client that allows you to build test suites for web APIs). Whilst having an extensive feature-set for a REST client, Insomnia lacked control-flow constructs for complex request and response handling. Constructs such as conditionals, looping, and error handling, are missing/very hard to implement. Soon after, the tests written in Insomnia were abandoned in favour of refactored versions of the previous tests within the code base itself.

Due to this need of greater functionality, I propose a scripting language purposefully designed as a HTTP client and test suite first.

\begin{center}
\verb|sttp| \textit{(amalgamation of `scripting' and `HTTP')}
\end{center}

\verb|sttp| was made in order to test web APIs that have complex interaction flows, or APIs that are just black boxes. The main features that \verb|sttp| was designed in mind with are:

\begin{enumerate}
    \item \textbf{Builtin HTTP client}. There must be a way to make HTTP requests.
    \item \textbf{Concise, quick and manageable builtin testing}. Tests should be easily implementable and modifiable. There should also be a way of grouping tests for actions that access a similar resource. Just like how REST APIs are designed.
    \item \textbf{JSON values and JSONPath}. All values in \verb|sttp| should be parsable to JSON and back. As most web APIs default to JSON as their interchange format, it makes sense to treat all data as JSON. \textbf{JSONPath}, is a syntax for accessing JSON values in the similar vain of XPath for XML\textsuperscript{\cite{goessner_2007}}.
    \item \textbf{Executing HTTP requests concurrently}. Concurrency should be easy and encouraged.
    \item \textbf{Command line usage}. I regularly tinker and test endpoints on the command line. Thus I expect the \verb|sttp| interpreter to be able to be run from the command line. This means creating a \textbf{whitespace independent grammar} that allows for input to be typed on a single line.
    \item \textbf{Web scraping functionality}. Such as a HTML parser, tree search functions, and filtering.
\end{enumerate}

To achieve this, I decided to write an interpreter using Go\textsuperscript{\cite{the_go_programming_language}} and the participle parser generator\textsuperscript{\cite{thomas_2021}}. I chose Go as its accompanying toolset allows for quick testing and benchmarking. I knew this would be useful when developing the language and benchmarking the concurrency constructs within the language. This native tooling also allows for rapid development and less external dependencies. At the beginning of the project I was comfortable at writing code in Go, as I had used it for numerous other projects in the past.

I chose the participle parser generator, as it was (and still is) being actively developed, and had a plethora of examples available. It also has an interesting way of defining the accepted grammar for the generated parser. Encoding EBNF within the AST node type declarations, the instantiated versions of which will be returned by the generated parser (explained further whilst discussing the \hyperref[sec:four-function-calc]{four-function calculator}). However, the generated parsers are recursive descent parsers. This meant I had to design my language without any left-recursion. Thankfully, the iteration operator in participle's EBNF notation, solved some of the issues, such as left-associative operators.

\section{The Future}

As explained in the \hyperref[chap:motivations]{motivations introduction}, much of my professional life and pastimes involve creating and testing web APIs. Therefore, \verb|sttp| is something that I would hope to use in both domains. I plan on continuing development on \verb|sttp| in the background to add newer features that will solve issues that occur frequently in my work life. Go is also rising in popularity within the web API space, and now that I am fairly fluent in it, I hope to use it within the workplace soon.

As I enjoyed learning the theory behind programming language design and engineering as much as I enjoyed creating \verb|sttp|. I hope I can make better use of this knowledge in the appropriate field of work. I have found the material covered within \textit{CS3480: Software Language Engineering}, quite eye-opening as to the number of different Domain Specific Languages (DSL), in use and in development. There is a DSL for everything from CAD 3D modelling to programming robots\textsuperscript{\cite{nordmann_hochgeschwender_wrede_2014}}. A job within this area could have work that I find rewarding and interesting.

\section{How to read this report}

This report is split into two-broad parts. The first reads as a quick introduction to web-APIs and how to use them, as well as how the \verb|sttp| programming language fits into this space. It also includes examples and explanations of how to program in \verb|sttp|, and outlines the problems that it solves. The second, reads as an in-depth technical overview of \verb|sttp|'s development with specific details on the data-structures and algorithms used. This section will dive into specific source-code listings within the interpreter, and it assumes an intermediate knowledge of programming within Go.

The reason behind this split was so that readers can get a reasonable understanding of how \verb|sttp| might work internally, through the real-world problems that it solves. It also enables those with more general expertise in computer science to get to grips with \verb|sttp| quicker.

\cprotect\part{Meet \verb|sttp|}

\chapter{Web APIs and where to find them}

In this chapter we will discuss the types of web-APIs, give some introductory \verb|sttp| code, and create a small theoretical web API that serves as an interface for a \textbf{blog website}.

\section{Web-APIs}

One important disambiguation to establish before continuing with the report is what kind web APIs that we are going to focus on.

\subsection{Client side Web APIs}

When a web API is client side, it means that it is running directly within a user's web browser or HTTP client. The Mozilla Foundation \href{https://developer.mozilla.org/en-US/docs/Web/API}{outlines all of the client side web APIs} that can be used when developing a HTML5 application. These are \textbf{not} the web APIs that we will refer to for the rest of the report.

\subsection{Server side Web APIs}

As mentioned in the \hyperref[chap:motivations]{motivations} chapter, server side web APIs offer one-or-more user exposed endpoints that perform specific actions within a service. \cprotect\textbf{\verb|sttp| was written in order to test these actions}.

\cprotect\section{\verb|sttp| is a HTTP client}
\label{sec:meet-sttp-http-clients}

Server side web APIs require the use of a HTTP client to communicate with them. HTTP clients make and accept HTTP requests and responses. Examples of HTTP clients include: \href{https://github.com/curl/curl}{cURL}, \href{https://www.gnu.org/software/wget/}{Wget}, \href{https://httpie.io/}{HTTPie}, and web browsers. On its base level, \cprotect\textbf{\verb|sttp| is just a HTTP client} wrapped within an iterative/procedural programming language.

For instance, when visiting the domain: \verb|https://www.example.com/| within a web browser; the web browser will act as a HTTP client, requesting the resource found at that URL (this might be a webpage, CSV, PDF, JSON, etc.). Below shows some similar commands for retrieving this resource using the different HTTP clients mentioned above:

\begin{enumerate}
    \item cURL: \mintinline[breaklines]{sh}{curl https://www.example.com/}
    \item Wget: \mintinline[breaklines]{sh}{wget https://www.example.com/}
    \item HTTPie: \mintinline[breaklines]{sh}{http GET https://www.example.com/}
    \item \verb|sttp|: \verb|$GET("https://www.example.com/")|
\end{enumerate}

\section{Web APIs services}

Typically, when talking about server side web APIs we assume that a web API \textbf{talks to a service}. For example, a service could be a database of exchange rates. The web API for this service might have an \textbf{endpoint} consisting of the following URL path construction: \verb|/{from}/{to}|. Making a \verb|GET| request to the URL: \verb|/GBP/USD| (using a HTTP client) will return the exchange rate from GBP to USD for the previous day as a \verb|JSON| object.

This allows subscribers to these services to \textbf{access them without much knowledge of the internal system itself}. \textbf{Endpoints} is the term usually given for a URL schema with a specific action tied to it. Information pertaining to the request is usually encoded within the URL itself: \verb|/GBP/USD|, placed within the query parameters: \verb|/today?from=GBP&to=USD|, or placed in the body of the HTTP request itself (if the HTTP method allows it). These endpoints are then tied to certain actions within these services by the web API developers. Actions such as: usually getting, creating, updating, and deleting resources are common actions tied to external endpoints.

\section{Web API intricacies}

When web APIs are modelled for large and intricate services, the layout of the endpoints for them can become cluttered very quickly. Thus, web API developers usually find it necessary to follow a convention for defining these endpoints. These conventions define how a set of actions might be mapped onto a URL and HTTP request methods (GET, POST, PUT, ...). One of the most popular of these conventions at the moment is: REST. A web API is considered RESTful if it adhere to a set of principles\textsuperscript{\cite{richardson_ruby_2007}}. The most relevant of these, to the current discussion on endpoints, is the \textbf{uniform interface} principle. This enforces that all RESTful APIs must\textsuperscript{\cite{fielding_2000}}:

% https://archive.org/details/restfulwebservic00rich_0

\begin{enumerate}
    \item \textbf{Identify resources within endpoints that access that specific resource}. For instance, if the web API is an interface for a blogging service, and blog resources are identified by a \href{https://www.uuidgenerator.net/version4}{UUID4}, then the following URL path might be constructed to access the comments on a blog: \verb|/blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993/comments|.
    \item \textbf{Manipulate resources through representations of the internal structure of said resources}. Continuing the blogging service example, when requesting a specific blog this might fetch a row from the service's database and then \textbf{serialise} it into a media type such as \verb|JSON|. For example, the request \verb|GET /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| might return the following \verb|JSON| data:
    \begin{minted}{json}
{
    "id": "1a88249b-4b93-4b7f-b38c-d967af5a7993",
    "name": "RESTful APIs",
    "author": "Jane Doe",
    "tags": [
        "Web APIs",
        "APIs",
        "REST"
    ]
}    
    \end{minted}
    This serialised blog returns all the data necessary to manipulate it. For instance, to update the name of the blog, the author might send the following request: \\\verb|PUT /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| with the body: \mintinline[breaklines]{json}{{"name": "RESTful Web APIs"}}. \cprotect\textit{Note how the body of the request is just a partial version of the data returned by \verb|GET|ting the same endpoint}.
\end{enumerate}

Hopefully this gives some indication as to how web APIs are created and used to access services. In the following chapter I will create an example web API that will be used throughout the first part of this report.

\chapter{Theorising a simple REST web API}

In this chapter we will create a theoretical REST web API to access a blogging service (similar to the one used as an example at the end of the last). This example web API will then be used throughout the first part as a common example.

\section{Formal definition of the blogging service}

The blogging service in question has three different resources, all of which are stored in their own tables within an internal database. This database \textbf{cannot} be accessed by end-users of the blogging service.

\begin{enumerate}
    \item \textbf{Topics}: each topic has a \textbf{unique ID}, the \textbf{number of blogs residing within it}, and a \textbf{name}.
    \item \textbf{Blogs}: each blog has a \textbf{unique ID}, a \textbf{name}, a \textbf{body}, the \textbf{author's name}, a \textbf{link to the topic it resides in}, and a \textbf{list of tags}.
    \item \textbf{Comments}: each comment has a \textbf{unique ID}, a \textbf{body}, the \textbf{commentor's name}, and the \textbf{link to a blog}.
\end{enumerate}

It is worth noting that although these resources describe parts of the internal database. It might still might mean that when requesting said resources, the server will add additional properties to them. For instance, with the \textbf{Topics} resource, storing the number of blogs within that topic within the database could be seen as inneligant. This is because each time a blog is created, its corresponding topic must have its blog counter incremented within the database. Instead, one might \textbf{bind this blog counter information when the request is being handled}. This is much more robust, and means less database interaction overall.

We will assume that the API for this service serves its responses as, and accepts its requests in \verb|JSON|. The \verb|JSON| serialised versions of these resources are constructed from the properties of that specific resource, where the keys of the object are snake-cased versions of the property name.

\section{The actions that are defined for users of the service}

A user of the service must be able to perform the following actions. Each action has been grouped under its relevant resource type, and assigned an endpoint and HTTP method.

For simplicity, we will assume that all users have permission to do everything. In a production web API, this would not be the case. Tokens would be used to authenticate the user and authorised using some sort of access control list.

\begin{itemize}
    \item Topics
    \begin{itemize}
        \item List all topics: \verb|GET /topics|
        \item Create a topic: \verb|POST /topics|
        \item Get a topic: \verb|GET /topics/{topic_id}|
        \item Update a topic: \verb|PUT /topics/{topic_id}|
        \item Delete a topic: \verb|DELETE /topics/{topic_id}|
        \item Get the top 10 topics by the number of blogs within them: \verb|GET /topics/top|
        \item Get the blogs for a topic: \verb|GET /topics/{topic_id}/blogs|
    \end{itemize}
    \item Blogs
    \begin{itemize}
        \item List all blogs: \verb|GET /blogs|
        \item Create a blog: \verb|POST /blogs|
        \item Get a blog: \verb|GET /blogs/{blog_id}|
        \item Update a blog: \verb|PUT /blogs/{blog_id}|
        \item Delete a blog: \verb|DELETE /blogs/{blog_id}|
        \item Get the comments for a blog: \verb|GET /blogs/{blog_id}/comments|
    \end{itemize}
    \item Comments
    \begin{itemize}
        \item Create a comment: \verb|POST /comments|
        \item Get a comment: \verb|GET /comments/{comment_id}|
        \item Update a comment: \verb|PUT /comments/{comment_id}|
        \item Delete a comment: \verb|DELETE /comments/{comment_id}|
    \end{itemize}
\end{itemize}

By splitting our endpoints by resource, we can more efficiently communicate the different parts of the API. This makes using it easier.

\section{How would you use this API?}

This API does not make much sense as a standalone system. However, it makes more sense as a server application in a client-server architecture. By this I mean that the client application could be a HTTP client, or even another web server. In the case of a blogging service, it would make sense for there to be a seperate web server that hosts a set of webpages. These webpages then make requests to the web API to manipulate the service. This external facing web server is usually known as the `\textbf{frontend}', whereas the web API, along with the internal database, is known as the `\textbf{backend}'.

Whether or not to restrict this web API completely to the \textbf{frontend} for security, or to make it publicly available so that users can programmatically utilise the service, is ultimately up to the maintainers. Personally, in this situation, I would restrict access to the web API to just the frontend web server in order to avoid user spam of the creation endpoints.

\subsection{Some example HTTP requests using HTTPie}

I've chosen HTTPie as a HTTP client for these examples as the commands themselves are similar to how a raw HTTP request is structured. For more information on how to use HTTPie the documentation can be found \href{https://httpie.io/docs/cli/examples}{here}.

\cprotect\textit{These examples presume that the web API is hosted on a web server with the domain: \verb|example.com|.}

\begin{enumerate}
    \item Create a new topic on `Web APIs':
    \begin{minted}[breaklines]{sh}
http POST https://example.com/topics name='Web APIs' 
    \end{minted}
    Usually after creating a resource, the serialised version of that resource is returned back to the user.
    \begin{minted}[breaklines]{json}
{
    "id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "blog_count": 0,
    "name": "Web APIs"
}
    \end{minted}
    \item Create a new blog for the topic we have just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/blogs name='RESTful APIs' body='Blah Blah' author='Jane Doe' tags:='["Web APIs", "APIs", "REST"]' topic_id='26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3'
    \end{minted}
    Again returning back a serialised version of the resource:
    \begin{minted}[breaklines]{json}
{
    "id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "name": "RESTful APIs",
    "body": "Blah Blah",
    "author": "Jane Doe",
    "topic_id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "topic_url": "https://example.com/topics/26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "tags": ["Web APIs", "APIs", "REST"]
}
    \end{minted}
    \item We can then add a comment to the blog that was just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/comments body='Great blog!' author='John Doe' blog_id='44e8b997-a3be-4813-b439-efd2a9d3ca10'
    \end{minted}
    The created comment\dots
    \begin{minted}[breaklines]{json}
{
    "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
    "body": "Great blog!",
    "author": "John Doe",
    "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
}
    \end{minted}
    \item Fetching the comments for a blog will return a list of serialised comment objects:
    \begin{minted}[breaklines]{sh}
http GET https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10/comments
    \end{minted}
    \begin{minted}[breaklines]{json}
[
    {
        "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
        "body": "Great blog!",
        "author": "John Doe",
        "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
        "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
    }
]
    \end{minted}
\end{enumerate}

How does \verb|sttp| fit into this equation?

\cprotect\chapter{Hello \verb|sttp|}

\begin{center}
    \textit{How would someone go about maintaining, testing, and extending the web API described above?}
\end{center}

This question might be asked when the project passes hands or a new developer is brought in who needs to be onboarded quickly. A rudimentary answer to this question might be to create test scripts using the command-line HTTP clients discussed in \hyperref[sec:meet-sttp-http-clients]{chapter 2}. However, from experience, this soon becomes quite unweildy as you need to create a test runner that crawls a given directory structure, or worse yet, whenever a new test needs to be added the whole test runner needs to be rewritten.

\begin{center}
    \textit{Is there another solution?}
\end{center}

Yes. As server side web APIs became more popular, many other people experienced similar problems with conventional HTTP clients. API clients are HTTP clients that allow the user to not only make HTTP requests, but to test specific endpoints, and sometimes even to design entire APIs. Although these API clients are feature rich, they lack the control flow available when using just scripting languages. \verb|sttp| hopes to be the API client/HTTP client/scripting language that fits between these two domains.

\begin{listing}
    \begin{verbatim}
// Setting variables using JSONPath
foo.bar.baz = "hello world";

// Calling functions stored within a variable by using the "$" prefix
$print(foo);
    \end{verbatim}
\end{listing}

\part{Technical}

To fully understand the technical information within this part, it is recommended that you first read through the sections on test programs. These will run through the functionality utilised by the participle parser generator library, as well as some of the general feature-set of Go that is heavily utilised in the \verb|sttp| interpreter.

\chapter{Development}
\label{chap:development}

Before development began I wrote a few test programs to get back up to speed with programming in Go, as well as familiarising myself with participle.

\import{sections}{2-1-four-func-calc.tex}

\import{sections}{2-2-regex-minimiser.tex}

\import{sections}{2-3-grammar-ast.tex}

\import{sections}{2-4-data-structures.tex}

\import{sections}{2-5-casting.tex}

\import{sections}{2-6-operators.tex}

\section{Evaluating AST nodes}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``Made final touches to interim report before handing in. Completed all operator actions as well as defining agnostic evaluation methods for all precedence levels. I also implemented assignment statements as well as if-elif-else statements. Along with JSONPath setting and getting. I had to rewrite my Heap data structure and my Value structure."}\\[0.5em]
        \tiny{11:51 am on December 6, 2021}
    \end{center}
\end{figure}
    
Each AST node within \verb|sttp| implements the \verb|evalNode| interface. This defines the \mintinline[breaklines]{go}{Eval(vm VM) (err error, result *data.Value)} instance method (among other things), that will be called on the root AST node (\verb|Program|) with a fresh \verb|VM| instance. The \verb|Eval| instance method of each lower AST node will be called as the interpreter executes a depth-first leftmost tree traversal; passing the \verb|VM| instance to each. The \verb|err| return parameter is used to `bubble' up an error/exception if one occurs in any of the AST nodes. This error will either float up to the \verb|Program| root, or to a \verb|TryCatch| AST node. The \verb|evalNode| interface was mainly implemented to improve readability and reduce complexity with the evaluation of AST nodes within \hyperref[sec:development-ast-nodes-expressions]{expression subtrees}.

\import{sections}{2-7-1-jsonpath-assignment.tex}

\import{sections}{2-7-2-expressions.tex}

\import{sections}{2-7-3-if-elif-else.tex}

\import{sections}{2-7-4-iterations.tex}

\import{sections}{2-7-5-functions.tex}

\import{sections}{2-7-6-http-methods.tex}

\import{sections}{2-7-7-testing.tex}

\import{sections}{2-7-8-try-catch-throw.tex}

\import{sections}{2-7-9-batch-statement.tex}

\import{sections}{2-7-10-builtins.tex}

\import{chapters}{3-evaluation.tex}

\import{chapters}{4-discussion.tex}

\import{chapters}{5-professional-issues.tex}

%%%%%%%%%%%%%%%%%%%%%%
%%% sttp Specification

\appendix

\cprotect\chapter{\verb|sttp| Specification}
\label{appendix:sttp-specification}

\verb|sttp| (amalgamation of \textit{scripting} and \textit{HTTP}) is a dynamically typed, interpreted, scripting language written in Go using the participle parser generator by Alec Thomas\textsuperscript{\cite{thomas_2021}}. For information on how to run the \verb|sttp| interpreter, check the \verb|README|. Below is the formal grammar definition of the language:

\import{../specification_for_language}{specification_for_language_body.tex}

\cprotect\chapter{\verb|sttp| Examples}
\label{appendix:sttp-examples}

\cprotect\textit{Located in: \verb|src/_examples/example_XX|}

\verb|sttp| examples that are run as unit tests for the \verb|sttp| interpreter. Please read the \verb|README| to find out how to build/run the \verb|sttp| interpreter from source. The expected stdout, stderr, test output, and error output will be located within the example's directory, \textbf{if it has an output available}.

\cprotect\textit{Note: some of these examples require the echo-chamber web API to be running alongside the \verb|sttp| interpreter. This can be found in \verb|src/_examples/echo_chamber/main.js|, and can be run using \verb|node|.}

\section{Example 1 - Catch all}
\label{appendix:sttp-examples-1}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_01/example_01.sttp}

\section{Example 2 - JSONPath}
\label{appendix:sttp-examples-2}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_02/example_02.sttp}

\section{Example 3 - IfElifElse}
\label{appendix:sttp-examples-3}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_03/example_03.sttp}

\section{Example 4 - While}
\label{appendix:sttp-examples-4}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_04/example_04.sttp}

\section{Example 5 - For}
\label{appendix:sttp-examples-5}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_05/example_05.sttp}

\section{Example 6 - ForEach}
\label{appendix:sttp-examples-6}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_06/example_06.sttp}

\section{Example 7 - FunctionDefinition and FunctionCall}
\label{appendix:sttp-examples-7}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_07/example_07.sttp}

\section{Example 8 - Recursive FunctionCalls}
\label{appendix:sttp-examples-8}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_08/example_08.sttp}

\section{Example 9 - MethodCalls}
\label{appendix:sttp-examples-9}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_09/example_09.sttp}

\section{Example 10 - TryCatch}
\label{appendix:sttp-examples-10}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_10/example_10.sttp}

\section{Example 11 - Batch}
\label{appendix:sttp-examples-11}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_11/example_11.sttp}

\section{Example 12 - Free builtin}
\label{appendix:sttp-examples-12}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_12/example_12.sttp}

\section{Example 13 - Find builtins}
\label{appendix:sttp-examples-13}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_13/example_13.sttp}

\section{Example 14 - Escape characters}
\label{appendix:sttp-examples-14}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_14/example_14.sttp}

\section{Example 15 - Breaking and returning}
\label{appendix:sttp-examples-15}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_15/example_15.sttp}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}

\printbibheading
\printbibliography[keyword=cite,heading=subbibliography,title={Cited material}]%
\nocite{*}
\printbibliography[keyword=nocite,heading=subbibliography,title={Supplementary material}]

\end{document}

\end{article}
