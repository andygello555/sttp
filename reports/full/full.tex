\documentclass[]{full}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{caption}
\usepackage{import}
\usepackage[style=ieee]{biblatex}
\usepackage[table,xcdraw]{xcolor}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{mathtools}
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}

% \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
% \AfterEndEnvironment{minted}{\end{tcolorbox}}%

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2022}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count:

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 2022

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Motivations}
\label{chap:motivations}

\begin{definition}[Server side Web API]
    A server side web API is an application programming interface that is hosted on a web server accessible via the HTTP protocol. Endpoints within a web API specify where an action or resource lies, creating a \textbf{directory like structure} of `methods'.
\end{definition}

Web APIs are in the background of most applications and services we use. Everything from requesting the weather in a certain country, accessing up to date exchange rate information, to accessing personal calendar information, can all be achieved through the use of specific web APIs. The number of web APIs has risen substantially over the last decade and a half. \href{https://www.programmableweb.com/category/all/apis}{ProgrammableWeb}, cites over 24,000 APIs (as of January 2022). A large increase from 2013: 9000, and an even larger increase from 2005: 105\textsuperscript{\cite{duvander_2013}}.

\begin{definition}[Web Scraping]
    Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites\textsuperscript{\cite{web_scraping_wikipedia_2022}}.
\end{definition}

Partly due to the ubiquity of web APIs, as well as my interest toward creating autonomous web-scraping solutions. I have gained a lot of experience using them, and have even developed a few of my own. Before beginning this project, I had been working on a large library of web scraping procedures, to track, scrape, and store information on several hundreds of applications on the popular PC video game e-tailer: \href{https://store.steampowered.com/}{Steam}. This was largely achieved by using Steam's Web API, but also by scraping data directly from webpages, dashboards, and portals. The data retrieved by said procedures would be stored in a database, accessible via a web API. Most of the endpoints within this API perform various complex manipulations and aggregations to return a representation of the data that is easier to handle for users. This interest soon stemmed into my professional life, when I was asked to implement this system on a larger scale for a indie video game publisher. Thus increasing the workload and data throughput of the server.

Soon, the complexity of the codebase spiralled out of control. The test suites that were written to check if the procedures were functioning properly, became large and unruly. Frequent and undocumented changes to the Steam Web API, would render some procedures out of action for several days. To deal with this issue, I moved the implementation of some of the test suites to \href{https://insomnia.rest/}{Insomnia} (a REST client that allows you to build test suites for web APIs). Whilst having an extensive feature-set for a REST client, Insomnia lacked control-flow constructs for complex request and response handling. Constructs such as conditionals, looping, and error handling, are missing/very hard to implement. Soon after, the tests written in Insomnia were abandoned in favour of refactored versions of the previous tests within the code base itself.

Due to this need of greater functionality, I propose a scripting language purposefully designed as a HTTP client and test suite first.

\begin{center}
\verb|sttp| \textit{(amalgamation of `scripting' and `HTTP')}
\end{center}

\verb|sttp| was made in order to test web APIs that have complex interaction flows, or APIs that are just black boxes. The main features that \verb|sttp| was designed in mind with are:

\begin{enumerate}
    \item \textbf{Builtin HTTP client}. There must be a way to make HTTP requests.
    \item \textbf{Concise, quick and manageable builtin testing}. Tests should be easily implementable and modifiable. There should also be a way of grouping tests for actions that access a similar resource. Just like how REST APIs are designed.
    \item \textbf{JSON values and JSONPath}. All values in \verb|sttp| should be parsable to JSON and back. As most web APIs default to JSON as their interchange format, it makes sense to treat all data as JSON. \textbf{JSONPath}, is a syntax for accessing JSON values in the similar vain of XPath for XML\textsuperscript{\cite{goessner_2007}}.
    \item \textbf{Executing HTTP requests concurrently}. Concurrency should be easy and encouraged.
    \item \textbf{Command line usage}. I regularly tinker and test endpoints on the command line. Thus I expect the \verb|sttp| interpreter to be able to be run from the command line. This means creating a \textbf{whitespace independent grammar} that allows for input to be typed on a single line.
    \item \textbf{Web scraping functionality}. Such as a HTML parser, tree search functions, and filtering.
\end{enumerate}

To achieve this, I decided to write an interpreter using Go\textsuperscript{\cite{the_go_programming_language}} and the participle parser generator\textsuperscript{\cite{thomas_2021}}. I chose Go as its accompanying toolset allows for quick testing and benchmarking. I knew this would be useful when developing the language and benchmarking the concurrency constructs within the language. This native tooling also allows for rapid development and less external dependencies. At the beginning of the project I was comfortable at writing code in Go, as I had used it for numerous other projects in the past.

I chose the participle parser generator, as it was (and still is) being actively developed, and had a plethora of examples available. It also has an interesting way of defining the accepted grammar for the generated parser. Encoding EBNF within the AST node type declarations, the instantiated versions of which will be returned by the generated parser (explained further whilst discussing the \hyperref[sec:four-function-calc]{four-function calculator}). However, the generated parsers are recursive descent parsers. This meant I had to design my language without any left-recursion. Thankfully, the iteration operator in participle's EBNF notation, solved some of the issues, such as left-associative operators.

\section{The Future}

As explained in the \hyperref[chap:motivations]{motivations introduction}, much of my professional life and pastimes involve creating and testing web APIs. Therefore, \verb|sttp| is something that I would hope to use in both domains. I plan on continuing development on \verb|sttp| in the background to add newer features that will solve issues that occur frequently in my work life. Go is also rising in popularity within the web API space, and now that I am fairly fluent in it, I hope to use it within the workplace soon.

As I enjoyed learning the theory behind programming language design and engineering as much as I enjoyed creating \verb|sttp|. I hope I can make better use of this knowledge in the appropriate field of work. I have found the material covered within \textit{CS3480: Software Language Engineering}, quite eye-opening as to the number of different Domain Specific Languages (DSL), in use and in development. There is a DSL for everything from CAD 3D modelling to programming robots\textsuperscript{\cite{nordmann_hochgeschwender_wrede_2014}}. A job within this area could have work that I find rewarding and interesting.

\chapter{How to read this report}

This report is split into two-broad parts. The first reads as a quick introduction to web-APIs and how to use them, as well as how the \verb|sttp| programming language fits into this space. It also includes examples and explanations of how to program in \verb|sttp|, and outlines the problems that it solves. The second, reads as an in-depth technical overview of \verb|sttp|'s development with specific details on the data-structures and algorithms used. This section will dive into specific source-code listings within the interpreter, and it assumes an intermediate knowledge of programming in Go.

The reason behind this split was so that readers can get a reasonable understanding of how \verb|sttp| might work internally, through the real-world problems that it solves. It also enables those with more general expertise in computer science to get to grips with \verb|sttp| quicker.

\cprotect\part{Meet \verb|sttp|}

\chapter{Web APIs and where to find them}

In this chapter we will discuss the types of web-APIs, create a small theoretical web API that serves as an interface for a \textbf{blog website}, and finally introduce \verb|sttp| and explain how it fits in this domain.

\section{Web-APIs}

One important disambiguation to establish before continuing with the report is what kind web APIs that we are going to focus on.

\subsection{Client side Web APIs}

When a web API is client side, it means that it is running directly within a user's web browser or HTTP client. The Mozilla Foundation \href{https://developer.mozilla.org/en-US/docs/Web/API}{outlines all of the client side web APIs} that can be used when developing a HTML5 application. These are \textbf{not} the web APIs that we will refer to for the rest of the report.

\subsection{Server side Web APIs}

As mentioned in the \hyperref[chap:motivations]{motivations} chapter, server side web APIs offer one-or-more user exposed endpoints that perform specific actions within a service. \cprotect\textbf{\verb|sttp| was written in order to test these actions}.

\cprotect\section{\verb|sttp| is a HTTP client}
\label{sec:meet-sttp-http-clients}

Server side web APIs require the use of a HTTP client to communicate with them. HTTP clients make and accept HTTP requests and responses. Examples of HTTP clients include: \href{https://github.com/curl/curl}{cURL}, \href{https://www.gnu.org/software/wget/}{Wget}, \href{https://httpie.io/}{HTTPie}, and web browsers. On its base level, \cprotect\textbf{\verb|sttp| is just a HTTP client} wrapped within an iterative/procedural programming language.

For instance, when visiting the domain: \verb|https://www.example.com/| within a web browser; the web browser will act as a HTTP client, requesting the resource found at that URL (this might be a webpage, CSV, PDF, JSON, etc.). Below shows some similar commands for retrieving this resource using the different HTTP clients mentioned above:

\begin{enumerate}
    \item cURL: \mintinline[breaklines]{sh}{curl https://www.example.com/}
    \item Wget: \mintinline[breaklines]{sh}{wget https://www.example.com/}
    \item HTTPie: \mintinline[breaklines]{sh}{http GET https://www.example.com/}
    \item \verb|sttp|: \verb|$GET("https://www.example.com/")|
\end{enumerate}

\section{Web API services}

Typically, when talking about server side web APIs we assume that a web API \textbf{talks to a service}. For example, a service could be a database of exchange rates. The web API for this service might have an \textbf{endpoint} consisting of the following URL path construction: \verb|/{from}/{to}|. Thus, making a \verb|GET| request to the URL: \verb|/GBP/USD| (using a HTTP client) could return the exchange rate from GBP to USD for the previous day as a \verb|JSON| object.

This allows subscribers to these services to \textbf{access them without much knowledge of the internal system itself}. \textbf{Endpoints} is the term usually given for a URL schema with a specific action tied to it. Information pertaining to the request is usually encoded within the URL itself: \verb|/GBP/USD|, placed within the query parameters: \verb|/today?from=GBP&to=USD|, or placed in the body of the HTTP request itself (if the HTTP method allows it). These endpoints are then tied to certain actions within these services by the web API developers. Actions such as: getting, creating, updating, and deleting resources are commonly tied to external endpoints.

\section{Web API intricacies}

When web APIs are modelled for large and intricate services, the layout of the endpoints for them can become cluttered very quickly. Thus, web API developers usually find it necessary to follow a convention for defining these endpoints. These conventions define how a set of actions might be mapped onto a URL and HTTP request methods (GET, POST, PUT, ...). One of the most popular of these conventions at the moment is: REST. A web API is considered RESTful if it adhere to a set of principles\textsuperscript{\cite{richardson_ruby_2007}}. The most relevant of these, to the current discussion on endpoints, is the \textbf{uniform interface} principle. This enforces that all RESTful APIs must\textsuperscript{\cite{fielding_2000}}:

% https://archive.org/details/restfulwebservic00rich_0

\begin{enumerate}
    \item \textbf{Identify resources within endpoints that access that specific resource}. For instance, if the web API is an interface for a blogging service, and blog resources are identified by a \href{https://www.uuidgenerator.net/version4}{UUID4}, then the following URL path might be constructed to access the comments on a blog: \verb|/blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993/comments|.
    \item \textbf{Manipulate resources through representations of the internal structure of said resources}. Continuing the blogging service example, when requesting a specific blog this might fetch a row from the service's database and then \textbf{serialise} it into a media type such as \verb|JSON|. For example, the request \verb|GET /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| might return the following \verb|JSON| data:
    \begin{minted}{json}
{
    "id": "1a88249b-4b93-4b7f-b38c-d967af5a7993",
    "name": "RESTful APIs",
    "author": "Jane Doe",
    "tags": [
        "Web APIs",
        "APIs",
        "REST"
    ]
}    
    \end{minted}
    This serialised blog returns all the data necessary to manipulate it. For instance, to update the name of the blog, the author might send the following request: \\\verb|PUT /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| with the body: \mintinline[breaklines]{json}{{"name": "RESTful Web APIs"}}. \cprotect\textit{Note how the body of the request can be a partial version of the data returned by \verb|GET|ting the same endpoint}.
\end{enumerate}

Hopefully this gives some indication as to how web APIs are created and used to access services. In the following chapter I will create an example web API that will be used throughout the rest of the first part of this report.

\chapter{Theorising a simple REST web API}

In this chapter we will create a theoretical REST web API to access a blogging service (similar to the one used as an example at the end of the last). This example web API will then be used throughout the first part as a common example.

\section{Formal definition of the blogging service}

The blogging service in question has three different resources, all of which are stored in their own tables within an internal database. This database \textbf{cannot} be accessed by end-users of the blogging service.

\begin{enumerate}
    \item \textbf{Topics}: each topic has a \textbf{unique ID}, the \textbf{number of blogs residing within it}, and a \textbf{name}.
    \item \textbf{Blogs}: each blog has a \textbf{unique ID}, a \textbf{name}, a \textbf{body}, the \textbf{author's name}, a \textbf{link to the topic it resides in}, and a \textbf{list of tags}.
    \item \textbf{Comments}: each comment has a \textbf{unique ID}, a \textbf{body}, the \textbf{commentor's name}, and the \textbf{link to a blog}.
\end{enumerate}

It is worth noting that although these resources describe parts of the internal database. It might still might mean that when requesting said resources, the server will add additional properties to them. For instance, with the \textbf{Topics} resource, storing the number of blogs within that topic within the database could be seen as inneligant. This is because each time a blog is created, its corresponding topic must have its blog counter incremented within the database. Instead, one might \textbf{bind this blog counter information when the request is being handled}. This is much more robust, and means less database interaction overall.

We will assume that the API for this service serves its responses as, and accepts its requests in \verb|JSON|. The \verb|JSON| serialised versions of these resources are constructed from the properties of that specific resource, where the keys of the object are snake-cased versions of the property name. \verb|JSON| is a very popular choice of media type for REST APIs in particular.

\section{Defining the actions and endpoints for the service}

A user of the service must be able to perform the following actions. Each action has been grouped under its relevant resource type, and assigned an endpoint and HTTP method.

For simplicity, we will assume that all users have permission to do everything. In a production web API, this would not be the case. Tokens would be used to authenticate the user and authorised via an access control list.

\begin{itemize}
    \item Topics
    \begin{itemize}
        \item List all topics: \verb|GET /topics|
        \item Create a topic: \verb|POST /topics|
        \item Get a topic: \verb|GET /topics/{topic_id}|
        \item Update a topic: \verb|PUT /topics/{topic_id}|
        \item Delete a topic: \verb|DELETE /topics/{topic_id}|
        \item Get the top 10 topics by the number of blogs within them: \verb|GET /topics/top|
        \item Get the blogs for a topic: \verb|GET /topics/{topic_id}/blogs|
    \end{itemize}
    \item Blogs
    \begin{itemize}
        \item List all blogs: \verb|GET /blogs|
        \item Create a blog: \verb|POST /blogs|
        \item Get a blog: \verb|GET /blogs/{blog_id}|
        \item Update a blog: \verb|PUT /blogs/{blog_id}|
        \item Delete a blog: \verb|DELETE /blogs/{blog_id}|
        \item Get the comments for a blog: \verb|GET /blogs/{blog_id}/comments|
    \end{itemize}
    \item Comments
    \begin{itemize}
        \item Create a comment: \verb|POST /comments|
        \item Get a comment: \verb|GET /comments/{comment_id}|
        \item Update a comment: \verb|PUT /comments/{comment_id}|
        \item Delete a comment: \verb|DELETE /comments/{comment_id}|
    \end{itemize}
\end{itemize}

By splitting our endpoints by resource, we can more efficiently communicate the different parts of the API. This makes developing it, using it, and testing it easier.

\section{How would you use this API?}

This API does not make much sense as a standalone system. However, it makes more sense as a server application in a client-server architecture. By this I mean that the client application could be a HTTP client, or even another web server. In the case of a blogging service, it would make sense for there to be a seperate web server that hosts a set of webpages. These webpages then make requests to the web API to manipulate the service. This external facing web server is usually known as the `\textbf{frontend}', whereas the web API, along with the internal database, is known as the `\textbf{backend}'.

Whether or not to restrict this web API completely to the \textbf{frontend} for security, or to make it publicly available so that users can programmatically utilise the service, is ultimately up to the maintainers. Personally, in this situation, I would restrict access to the web API to just the frontend web server in order to avoid user spam of the creation endpoints.

\subsection{Some example HTTP requests using HTTPie}

I've chosen HTTPie as a HTTP client for these examples as the commands themselves are similar to how a raw HTTP request is structured. For more information on how to use HTTPie the documentation can be found \href{https://httpie.io/docs/cli/examples}{here}.

\cprotect\textit{These examples presume that the web API is hosted on a web server with the domain: \verb|example.com|.}

\begin{enumerate}
    \item Create a new topic on `Web APIs':
    \begin{minted}[breaklines]{sh}
http POST https://example.com/topics name='Web APIs' 
    \end{minted}
    Usually after creating a resource, the serialised version of that resource is returned back to the user.
    \begin{minted}[breaklines]{json}
{
    "id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "blog_count": 0,
    "name": "Web APIs"
}
    \end{minted}
    \item Create a new blog for the topic we have just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/blogs name='RESTful APIs' body='Blah Blah' author='Jane Doe' tags:='["Web APIs", "APIs", "REST"]' topic_id='26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3'
    \end{minted}
    Again returning back a serialised version of the resource:
    \begin{minted}[breaklines]{json}
{
    "id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "name": "RESTful APIs",
    "body": "Blah Blah",
    "author": "Jane Doe",
    "topic_id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "topic_url": "https://example.com/topics/26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "tags": ["Web APIs", "APIs", "REST"]
}
    \end{minted}
    \item We can then add a comment to the blog that was just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/comments body='Great blog!' author='John Doe' blog_id='44e8b997-a3be-4813-b439-efd2a9d3ca10'
    \end{minted}
    The created comment\dots
    \begin{minted}[breaklines]{json}
{
    "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
    "body": "Great blog!",
    "author": "John Doe",
    "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
}
    \end{minted}
    \item Fetching the comments for a blog will return a list of serialised comment objects:
    \begin{minted}[breaklines]{sh}
http GET https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10/comments
    \end{minted}
    \begin{minted}[breaklines]{json}
[
    {
        "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
        "body": "Great blog!",
        "author": "John Doe",
        "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
        "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
    }
]
    \end{minted}
\end{enumerate}

We have seen how to construct and use RESTful web APIs, but how does \verb|sttp| fit into this domain?

\cprotect\chapter{Hello \verb|sttp|}

\begin{center}
    \textit{How would someone go about maintaining, testing, and extending the web API described above?}
\end{center}

This question might be asked when the project passes hands or a new developer is brought in who needs to be onboarded quickly. A rudimentary answer to this question might be to create test scripts using the command-line HTTP clients discussed in \hyperref[sec:meet-sttp-http-clients]{chapter 2}. However, from experience, this soon becomes quite unweildy as you need to create a test runner that crawls a given directory structure, or worse yet, whenever a new test needs to be added the whole test runner needs to be rewritten.

\begin{center}
    \textit{Is there another solution?}
\end{center}

Yes. As server side web APIs became more popular, many other people experienced similar problems with conventional HTTP clients. API clients, such as \href{https://insomnia.rest/}{Insomnia} and \href{https://www.postman.com/}{Postman}, are HTTP clients that allow the user to not only make HTTP requests, but to test specific endpoints, and sometimes even to design entire APIs. Although these API clients are feature rich, they lack the control flow available when using a scripting language. \verb|sttp| hopes to be the API client/HTTP client/scripting language that fits between these two domains.

In the following section I will give a rough overview on the look-and-feel of the \verb|sttp| language. This is so that when explaining how \verb|sttp| would be used to \hyperref[sec:hello-sttp-using-sttp-to-test]{test web APIs}, the language won't seem as alien.

\cprotect\section{What does \verb|sttp| look like?}

\verb|sttp| is an interpreted imperative/procedural programming language that is dynamically-typed. The native types in \verb|sttp| are exactly similar to the ones used in the JSON interchange format:

\begin{verbatim}
string = "this is a string";
number = 1.23;  // 123 is also a number
boolean = true;
array = [1, "2", [3]];
object = {"hello": "world", "pi": 3.142};
n = null;
\end{verbatim}

\begin{itemize}
    \item \textbf{Strings}: sequences of characters surrounded by double quotes.
    \item \textbf{Numbers}: both integers and real numbers.
    \item \textbf{Booleans}: either \verb|false|, or \verb|true|.
    \item \textbf{Arrays}: an unbounded list of elements that can take any type, enclosed within square braces. Zero-indexed.
    \item \textbf{Objects}: a set of key-value pairs enclosed within curly braces. Keys must be String values.
    \item \textbf{Null}: \verb|null| is a falsy (evaluates to \verb|false|) value that indicates an empty value.
    \item Along with the types defined within the \verb|JSON| specification, we also have the additional \textbf{Function} type that represents the `pointer' to a function definition.
    \begin{verbatim}
// More on this later...
function foo()
    return "bar";
end;
// func contains a copy of the reference to foo
func = foo;    
    \end{verbatim}
\end{itemize}

Compound statements (anything that takes a nested `block') such as \verb|if|, \verb|while|, and \verb|for| are all terminated using the \verb|end| keyword, reminscient to Lua. Statements are seperated by semicolons, and functions are invoked by suffixing the function's path with a \verb|$| character. A comment is any line beginning with two forward slashes: \verb|//|. \verb|sttp| is whitespace independent, meaning that a program can be written on a single line. This is useful for quick prototyping through the command-line.

\begin{verbatim}
// Compound statements are still statements, so
// have to end with ";"
if true then
    // Call the print builtin using the "$" prefix
    $print("True is true, who would've known?");
end;

// Or write everything on one line...
if false then $print("Won't print..."); end;
\end{verbatim}

\subsection{JSONPath}

Variable assignment and dereference is achieved through JSONPath-like syntax. JSONPath is a syntax which can describe the path to any value within a \verb|JSON| Object, Array, or String. It is reminiscent to member access within Javascript.

\begin{verbatim}
// We define a variable foo, holding an Object value...
foo = {
    "array": [1, "2", [3]],
    "bar": "baz",
    "pi": 3.142
};

// If we wanted to print the 3rd element from the array
// with the key: "array", within the variable foo...
$print(foo.array[2]);

// We could also do...
$print(foo["array"][2]);

// Or even...
$print(foo[0][2]);

// All Objects in sttp are ordered lexicographically by
// their keys. This allows you to use integer indices to
// access values within Objects.
\end{verbatim}

Note the three ways of accessing a named property within an Object: \verb|.property|, \verb|["property"]|, or \verb|[i]|; where \verb|i| is the lexicographical index of the property to access in relation to the other keys.

Aside from simple member access, each property (\verb|.property|), or pair of square braces (\verb|[...]|), can be followed by a filter block. This is a block of \verb|sttp| code that will be run against each element of the value currently pointed to by the path. If this block returns a truthy value for an element, then that element will be added to a resulting Array. Otherwise, that element will not be added. Filter blocks are enclosed between two triple backticks: \verb|```...```|.

Each time a filter block is run against an element within the value, the variable \verb|curr| is set. \verb|curr| is an Object that has a \verb|key| key, and a \verb|value| key.

\verb|key| stores the key of the currently iterated element within the value that is being iterated over. This will be a Number index when iterating over a String, or an Array, and a String key when iterating over Objects.

\verb|value| stores the value of the currently iterated element within the value that is being iterated over. This can be any one of \verb|sttp|'s native types.

\begin{verbatim}
// If "foo" stores the value in the previous example...

// This will print the 3rd element from the value of the
// "array" key within foo. Note the final index access 
// after the filter to select the first element from the
// result Array.
$print(foo.array```
    return curr.key == 2;
```[0]);
\end{verbatim}

The examples up until now have been showcasing dereferencing variables via JSONPath, but \textbf{what if you want to assign a variable?} When it comes to assignment, \verb|sttp| employs a technique that (from what I can tell) is unique to \verb|sttp| alone. This technique is something that I've dubbed: \textbf{sparse-fill}. It allows Objects, Arrays, and Strings to be dynamically extended arbitrarily deep. For example:

\begin{verbatim}
foo = {"pi": 3.142};

// This will create the "bar" key within "foo"...
foo.bar = "foo bar";
// Same as: foo["bar"]

// This will create the "baz" key within a newly
// created Object residing within "bar"'s value
// within foo...
foo.bar.baz = "foo bar baz";
// Same as: foo["bar"]["baz"], foo.bar["baz"], ...

// But what about the value that was assigned to
// foo.bar? Don't worry it's still there...
$print(foo);

// The above print would output:
// {
//     "bar": {
//         "": "foo bar",
//         "baz": "foo bar baz"
//     },
//     "pi": 3.142
// }

// What are the ways of retrieving the old value
// of foo.bar?
$print(foo.bar[""]);
// Or...
$print(foo.bar[0]);
\end{verbatim}

Notice somethings interesting happens when sparsely filling \verb|foo.bar.baz|, when \verb|foo.bar| is already set to be a String. In this case, the next property within the JSONPath is accessing an Object key: \verb|.baz|, so the value initially stored at \verb|foo.bar| is moved to be the value of the empty string key (\verb|""|) within a `new' Object. There are two takeaways from this:

\begin{enumerate}
    \item When sparsely-filling a value, the next property in the JSONPath signifies what value will be created at that point.
    \begin{itemize}
        \item If the next property is a String index (\verb|["property"]|) or an Object key (\verb|.property|), then an Object will be created.
        \begin{enumerate}
            \item If a value already resides at that path, then it will be placed as a value of the empty string key (\verb|""|) within this newly created Object.
            \item This is done so that the old value can be retrieved by either a zero index (\verb|[0]|), as an \textbf{empty String will always be lexicographically first}, or by using a String index (\verb|[""]|).
        \end{enumerate}
        \item If the next property is a integer index (square braces container an integer), and the value to be set is not an Object, Array, or String, then an Array will be created.
        \begin{enumerate}
            \item If a value already resides at that path, then it will be placed in the position one index after the one being set.
            \item When creating a new Array, and setting an element greater than 0, \verb|null|s will be inserted up until the value to be set.
            \begin{verbatim}
foo = {"pi": 3.142};
foo.pi[3] = "not pi";
$print(foo);
// The above print would output:
// {
//     "pi": [
//         null,
//         null,
//         null,
//         "not pi",
//         3.142
//     ]
// }
            \end{verbatim}
        \end{enumerate}
    \end{itemize}
    \item JSONPath assignment is very \textbf{permissive} in what it can do, and will \textbf{rarely throw an error}. This is was one of the main design philosophies when creating \verb|sttp|.
\end{enumerate}

JSONPath assignment on String values also has an interesting behaviour, and you can achieve some pretty complex String formatting by using it.

\begin{verbatim}
foo = "foo";

// Concatenation...
foo[3] = "bar";
$print(foo);
// Outputs: foobar

// Concatenating with whitespace...
foo[4] = "bar";
$print(foo);
// Outputs: foo bar

// Replacing characters with Strings...
foo[0] = "bo";
$print(foo);
// Outputs: booo
\end{verbatim}

There are quite a lot of intricacies when it comes to JSONPath assignment and dereferencing within \verb|sttp|, and not all of it will be covered in the scope of this part.

\subsection{Expressions}

Both \textbf{boolean and arithmetic expressions are a part of the same precedence hierarchy}. \textbf{All operators are left-to-right associative}.

\subsubsection{Operator precedence}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| m{2cm} | m{2cm} | m{5cm} |}
            \hline
            Precedence & Operators & Description\\
            \hline
            \textbf{0} & \verb|* / %| & Multiplication, division, and modulus\\
            \hline
            \textbf{1} & \verb|+ -| & Addition and subtraction\\
            \hline
            \textbf{2} & \verb|< > <= >=| & Less than, greater than, less than or equal to, and greater than or equal to\\
            \hline
            \textbf{3} & \verb|== !=| & Equal and not equal\\
            \hline
            \textbf{4} & \verb|&&| & Logical and\\
            \hline
            \textbf{5} & \verb+||+ & Logical or\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Operators and their precedence from highest precedence (top) to lowest precedence (bottom)}
\end{figure}

Expressions, and subsequently operators, are evaluated from left to right. Most operator actions involve casting the right-hand side into the type of the value on the left-hand side, then finally performing the operation. This can be used to the benefit of the programmer for various needs, such as casting a value to another type.

\begin{verbatim}
// Here the Array will be cast to a Number, which will 
// result in the Array's length
array = [1, 2, 3];
array_length = 0 + [1, 2, 3];
\end{verbatim}

\subsubsection{Conditions}

In statements that require a predicate (such as `if-elif-else', `while', and `for' statements) a purely arithmetic, a purely logical operator expression, or a mixed expression can all be used. If the expression does not result in a value of a Boolean type, then the result will be cast into a Boolean using the truthy and falsy values below.

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            Type & Truthy value & Falsy value\\
            \hline
            Boolean & \verb|true| & \verb|false|\\
            \hline
            null & & \verb|null|\\
            \hline
            Number & \verb|!= 0| & \verb|0|\\
            \hline
            String & \verb|"..."| & \verb|""|\\
            \hline
            Object & \verb|{...}| & \verb|{}|\\
            \hline
            Array & \verb|[...]| & \verb|[]|\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Table of truthy and falsy values of each type}
\end{figure}

\subsection{Operators}

Instead of having built-in functions for operations such as appending to an array, removing from an array, merging objects, etc. Operators, perform most of these actions. The following operators remain unchanged for all types:

\begin{itemize}
    \item \textbf{Equal}: \textbf{Deep} equal. \textbf{Returns boolean}.
    \item \textbf{Not-equal}: \textbf{Deep} not-equal. \textbf{Returns boolean}.
    \item \textbf{Less-than, greater-than, less-than or equal, greater-than or equal}: First checks if the first operand is of type Number or String (comparable types). If not then the first operand will be tried to be cast into a Number, and then a String, and if it still cannot, an error will be returned. Then the second operand is cast into the type of the newly cast first operand, returning an error if required. Then these newly cast operands are compared and a Boolean value is returned. \textbf{Null cannot be compared}.
    \item \textbf{Logical And}: Compares by casting both operands to boolean values.
    \item \textbf{Logical Or}: Compares by casting both operands to boolean values.
\end{itemize}

Below, is a run through of each supported operation for each type. \textit{Note that this presumes that all of the types below are on the left-hand side of the operator.}

\subsubsection{Objects}

\begin{itemize}
    \item \textbf{Addition}: Will merge the RHS into the left overriding any values with the same key, returning a new Object.
    \begin{verbatim}
{"a": 1, "b": 2} + {"b": 3, "c": 4} == {"a": 1, "b": 3, "c": 4};
    \end{verbatim}
    \item \textbf{Subtraction}: Left value will have keys found in right value deleted from it, returning a new Object.
    \begin{verbatim}
{"a": 1, "b": 2, "c": 3} - {"b": "2", "d": "4"} == {"a": 1, "c": 3};
    \end{verbatim}
    \item \textbf{Divide}: Right associative set difference. $op2 - op1$ or $op2 \setminus op1$. This will still have to cast the RHS to an Object. It also returns a new Object.
    \begin{verbatim}
{"a": 1, "b": 2, "c": 3} / {"b": "2", "d": "4"} == {"d": "4"};
    \end{verbatim}
\end{itemize}

\subsubsection{Arrays}

\begin{itemize}
    \item \textbf{Addition}: If the right-hand value is not an Array, then it will be appended to the left value. If the right-hand value is an Array then the elements of the right-hand Array will be appended to the left-hand Array. This will return a new Array. Note that the RHS is \textbf{never cast} to the Array type.
    \begin{verbatim}
[1, 2] + 3 == [1, 2, 3]; [1] + [2, 3] == [1, 2, 3];
    \end{verbatim}
    \item \textbf{Subtraction}: Subtract elements from Array. All elements on the LHS Equal to the elements in the RHS will be removed. If the element is \verb|null| then the head of the Array is removed. The same element cannot be removed more than once in the same operation. This includes \verb|null|. A new Array will be returned.
    \begin{verbatim}
["foo", 1, 2, 3, "bar"] - [null, null, "bar"] == [1, 2, 3];
    \end{verbatim}
\end{itemize}

\subsubsection{Strings}

\begin{itemize}
    \item \textbf{Multiply}: Will repeat the String on the left $n$ times, where $n$ is the RHS cast to a Number.
    \begin{verbatim}
"foo" + "o" * 6 + "bar" == "foooooooobar";
    \end{verbatim}
    \item \textbf{Modulus}: If the RHS value is not of type String, then the RHS will be cast to an Array. String interpolation is performed on the String on the LHS using the verb `\verb|%%|'. If the RHS value is a String then this String will be treated as a singleton array, and the String interpolation will be carried out using this value.
    \begin{verbatim}
"Give me %%%!" % 110 == "Give me 110%!";
    \end{verbatim}
    \item \textbf{Addition}: Concatenation.
    \begin{verbatim}
"foo" + "bar" == "foobar";
    \end{verbatim}
    \item \textbf{Subtraction}: Depending on the type of the RHS the following will happen:
    \begin{itemize}
        \item \textbf{Number}:  Remove the last n digits from the String.
        \begin{verbatim}
"foobar" - 3 == "foo";
        \end{verbatim}
        \item \textbf{String}:  Remove all occurrences of the RHS from the LHS.
        \begin{verbatim}
"is null nullable?" - "null" == "is  able?";
        \end{verbatim}
        \item \textbf{Object}:  Replaces all occurrences of RHS's keys with String versions of their values.
        \begin{verbatim}
"foobarfoobaz" - {"foo": "bar", "baz": "foo"} == "barbarbarfoo";
        \end{verbatim}
        \item \textbf{Array}:   Casts each element in the array to a string and removes all occurrences of each from the LHS.
        \begin{verbatim}
"foobarmoobaz" - ["foo", "bar", "baz"] == "moo";
        \end{verbatim}
        \item \textbf{Default}: Casts RHS to string and removes all occurrences of it from the LHS.
        \begin{verbatim}
"truefalse" - false == "true";
        \end{verbatim}
    \end{itemize}
\end{itemize}

\subsubsection{Numbers}

All operators work as expected.

\subsubsection{Booleans}

\begin{itemize}
    \item \textbf{Multiply}: Same as Logical And.
    \begin{verbatim}
a * b == a && b;
    \end{verbatim}
    \item \textbf{Divide}: Inverse of Logical And (NAND).
    \begin{verbatim}
a / b != a && b;
    \end{verbatim}
    \item \textbf{Modulus}: The material conditional/Implies that. $op1 \rightarrow op2$.
    \begin{verbatim}
a % b == (a / a) || b;
    \end{verbatim}
    \item \textbf{Addition}: Same as Logical Or.
    \begin{verbatim}
a + b == a || b;
    \end{verbatim}
    \item \textbf{Subtraction}: Inverse of Logical Or (NOR).
    \begin{verbatim}
a - b != a || b;
    \end{verbatim}
\end{itemize}

\subsubsection{Nulls}

Multiply, Divide, Modulus, Addition, and Subtraction will all `nullify' the operation (result is \verb|null|). Null cannot be compared but can be used in logical expressions where it will be cast into \verb|false|.

\subsection{Casting}

\begin{center}
\textit{If a type is not mentioned in any of the sections below it means that the type cannot be cast to the missing type, and will return an error.}
\end{center}

\subsubsection{Casting from Objects}

\begin{itemize}
    \item \textbf{To Array}: Extracts the keys from the Object. Will always be an Array of Strings.
    \item \textbf{To String}: Marshals the Object as a JSON string.
    \item \textbf{To Number}: Returns the number of keys in the Object.
    \item \textbf{To Boolean}: If the Object is not empty (length is greater than 0) then the Object is truthy, otherwise the Object is falsy.
\end{itemize}

\subsubsection{Casting from Arrays}

\begin{itemize}
    \item \textbf{To Object}: Creates an Object where each key is an index of an element in the Array, the value of which is the element that lies at that index.
    \item \textbf{To String}: Marshals the Object as a JSON string.
    \item \textbf{To Number}: Returns the number of elements in the Array.
    \item \textbf{To Boolean}: If the Array is not empty then the Array is truthy, otherwise the Array is falsy.
\end{itemize}

\subsubsection{Casting from Strings}

\begin{itemize}
    \item \textbf{To Object}: Attempts to parse the String into a JSON Object.
    \item \textbf{To Array}: Attempts to parse the String into a JSON Array.
    \item \textbf{To Number}: Attempts to parse the String to an integer, then a float, and will finally just take the length of the String.
    \item \textbf{To Boolean}: If the String is not empty then the String is truthy, otherwise the String is falsy.
\end{itemize}

\subsubsection{Casting from Numbers}

\begin{itemize}
    \item \textbf{To Object}: Constructs a singleton Object where the key is the String representation of the Number, and the value is Null.
    \item \textbf{To Array}: Constructs a singleton Array where the first and only element is the Number.
    \item \textbf{To String}: Marshals the Number as a JSON number.
    \item \textbf{To Boolean}: Whether or not the Number is greater than 0.
\end{itemize}

\subsubsection{Casting from Boolean}

\begin{itemize}
    \item \textbf{To Object}: Constructs a singleton Object where the key is the String representation of the Boolean, and the value is Null.
    \item \textbf{To Array}: Constructs a singleton Array where the first and only element is the Boolean.
    \item \textbf{To String}: Marshals the Boolean as a JSON boolean.
    \item \textbf{To Number}: 0 if false, 1 otherwise.
\end{itemize}

\subsubsection{Casting from Null}

\begin{itemize}
    \item \textbf{To Object}: Constructs a singleton Object where the key is the String representation of Null (\verb|null|), and the value is Null.
    \item \textbf{To Array}: Constructs a singleton Array where the first and only element is Null.
    \item \textbf{To String}: \verb|null|.
    \item \textbf{To Number}: Returns false.
\end{itemize}

\subsubsection{Casting from Functions}

\begin{itemize}
    \item \textbf{To String}: \verb|function:JSON_PATH:SAFE_PTR|.
\end{itemize}

\subsection{A note on Functions}

Functions are defined as follows:

\begin{verbatim}
function foo(a, b)
    return a + b;
end;
\end{verbatim}

This places the value \verb|foo| on the heap of the current stack frame, with a value of type Function. This value points to the function's corresponding FunctionDefinition AST node. In \verb|sttp| this value will be treated as a String in the format: \verb|function:JSON_PATH:SAFE_PTR|.

\subsection{Call Stack}
\label{sec:function-call-stack}

Each time a function is called, the heap will be checked first for the called function, if the found value is not a function then the table of builtins will be checked.

\begin{verbatim}
// This will override the print builtin
function print(a) return a; end;

// This will just return "foo"
$print("foo");
\end{verbatim}

Each stack frame, including the first/main/global frame, will have a new heap allocated to it. This contains a mapping of variable names to \verb|sttp| values. Each local variable defined within the current frame will be allocated to this heap. All values defined as a global variable from the previous stack frame are copied by reference over to the new stack stack frame.

Each argument is assigned to the JSONPath defined in the function's parameters and placed on this heap. If there is no argument for a defined function parameter, then that parameter will be set to \verb|null|. If there are more arguments provided then there are parameters, then an error is thrown.

A \verb|self| variable is also placed on the heap which contains the value pointed to by the first/root property (in \verb|foo.bar.baz| this would be \verb|foo|) of the JSONPath of the function. For instance:

\begin{verbatim}
hello_world = {"name": "John Smith"};

function hello_world.hello()
    $print("Hello", self.name + "!");
end;

$hello_world.hello();
// Output: Hello John Smith!
\end{verbatim}

Parameters are assigned in order from left to right, with the \verb|self| parameter defined first. This can give way to some interesting behaviour such as the following:

\begin{verbatim}
foo = {"name": "John Smith"};

// "foo" is populated with new keys "a", "b", and "c"
function foo.zoo(self.a, self.b, foo.c)
    self.result = self.a * self.b * self.c;
end;

$foo.zoo(3, 7, 2);
$print(foo);
// Output: {
//     "a": 3,
//     "b": 7,
//     "c": 2,
//     "name": "John Smith",
//     "result": 42,
//     "zoo": "function:foo.zoo:XXXXXXX"
// }
\end{verbatim}

Once the function has completed execution, the current stack frame is popped from the call-stack.

\subsection{Method Calls (HTTP requests)}

\verb|sttp| is a HTTP client, so there must be a way of making HTTP requests. In \verb|sttp| these are called Method Calls. They are treated similarly to how you invoke a Function but the only supported signatures are:

\begin{itemize}
    \item \verb|$GET(URL String, Headers Object, Cookies Object)|
    \item \verb|$HEAD(URL String, Headers Object, Cookies Object)|
    \item \verb|$OPTIONS(URL String, Headers Object, Cookies Object)|
    \item \verb|$POST(URL String, Headers Object, Cookies Object, Body Any)|
    \item \verb|$PUT(URL String, Headers Object, Cookies Object, Body Any)|
    \item \verb|$DELETE(URL String, Headers Object, Cookies Object, Body Any)|
    \item \verb|$PATCH(URL String, Headers Object, Cookies Object, Body Any)|
\end{itemize}

Each signature accepts the \verb|URL|, \verb|Headers| and \verb|Cookies| parameter but only the HTTP methods that support a body within the request (\verb|POST|, \verb|PUT|, \verb|DELETE|, and \verb|PATCH|) accept the \verb|Body| parameter. As these parameters must be the types described in the signatures above, all arguments will be type checked and cast to ensure they have the correct types.

The response from a Method Call will be an Object that looks like the following:

\begin{verbatim}
{
    "content": The body of the response (Object / String),
    "cookies": [
        {
            "name": The cookie's name (String),
            "value": The cookie's value (String),
            "max_age": The cookie's max age (Number),
            "secure": Whether or not the cookie is secure (Boolean),
            "http_only": Whether or not the cookie is HTTP only (Boolean),
            "same_site": See https://pkg.go.dev/net/http#SameSite (Number),
            "raw": The raw representation of the cookie (String),
        },
        ...
    ],
    "headers": {
        "name": ["value_1", "value_2"],
        ...
    },
    "received": "2006-01-02 15:04:05.999999999 -0700 MST" (String),
    "size": Size in bytes (Number),
    "status": "200 OK" (String),
    "code": 200 (Number),
    "time": "0h0m0.5s" (String),
}
\end{verbatim}

\subsubsection{Content parsing}

If there is a body to the response then the interpreter will attempt to parse the body. The body will be first attempted to be parsed using Go's JSON library. If this fails then the body will be returned as a String.

If the body returned has a content type of `\verb|text/html|', the body will be parsed using Go's native HTML parser library, then the produced DOM will be traversed to construct an \verb|sttp| Object. The following rules are followed when traversing each node of the DOM to create the Object:

\begin{enumerate}
    \item If the node is a TextNode who's data is just whitespace (\verb|[ \t\n]|), then it will be ignored.
    \item Each of the node's children will be recursed down.
\end{enumerate}

Parsing HTML to an \verb|sttp| Object makes it easier to use with \verb|sttp|'s builtin object searching functions (such as \verb|find|, and could potentially be used for \textbf{web scraping}.

\cprotect\subsubsection{The \verb|batch| statement}

% Batch statement intro
When a Method Call is used within a \verb|batch| statement then it will be added to a `batch', executed in parallel at the end of the batch statement. This is described more in the \hyperref[sec:batching]{next} section.

\cprotect\section{Using \verb|sttp| to test web APIs}
\label{sec:hello-sttp-using-sttp-to-test}

WIP

\part{Technical}

To fully understand the technical information within this part, it is recommended that you first read through the sections on test programs. These will run through the functionality utilised by the participle parser generator library, as well as some of the general feature-set of Go that is heavily utilised in the \verb|sttp| interpreter.

\chapter{Development}
\label{chap:development}

Before development began I wrote a few test programs to get back up to speed with programming in Go, as well as familiarising myself with participle.

\import{sections}{2-1-four-func-calc.tex}

\import{sections}{2-2-regex-minimiser.tex}

\import{sections}{2-3-grammar-ast.tex}

\import{sections}{2-4-data-structures.tex}

\import{sections}{2-5-casting.tex}

\import{sections}{2-6-operators.tex}

\section{Evaluating AST nodes}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``Made final touches to interim report before handing in. Completed all operator actions as well as defining agnostic evaluation methods for all precedence levels. I also implemented assignment statements as well as if-elif-else statements. Along with JSONPath setting and getting. I had to rewrite my Heap data structure and my Value structure."}\\[0.5em]
        \tiny{11:51 am on December 6, 2021}
    \end{center}
\end{figure}
    
Each AST node within \verb|sttp| implements the \verb|evalNode| interface. This defines the \mintinline[breaklines]{go}{Eval(vm VM) (err error, result *data.Value)} instance method (among other things), that will be called on the root AST node (\verb|Program|) with a fresh \verb|VM| instance. The \verb|Eval| instance method of each lower AST node will be called as the interpreter executes a depth-first leftmost tree traversal; passing the \verb|VM| instance to each. The \verb|err| return parameter is used to `bubble' up an error/exception if one occurs in any of the AST nodes. This error will either float up to the \verb|Program| root, or to a \verb|TryCatch| AST node. The \verb|evalNode| interface was mainly implemented to improve readability and reduce complexity with the evaluation of AST nodes within \hyperref[sec:development-ast-nodes-expressions]{expression subtrees}.

\import{sections}{2-7-1-jsonpath-assignment.tex}

\import{sections}{2-7-2-expressions.tex}

\import{sections}{2-7-3-if-elif-else.tex}

\import{sections}{2-7-4-iterations.tex}

\import{sections}{2-7-5-functions.tex}

\import{sections}{2-7-6-http-methods.tex}

\import{sections}{2-7-7-testing.tex}

\import{sections}{2-7-8-try-catch-throw.tex}

\import{sections}{2-7-9-batch-statement.tex}

\import{sections}{2-7-10-builtins.tex}

\import{chapters}{3-evaluation.tex}

\import{chapters}{4-discussion.tex}

\import{chapters}{5-professional-issues.tex}

%%%%%%%%%%%%%%%%%%%%%%
%%% sttp Specification

\appendix

% \cprotect\chapter{\verb|sttp| Specification}
% \label{appendix:sttp-specification}

% \verb|sttp| (amalgamation of \textit{scripting} and \textit{HTTP}) is a dynamically typed, interpreted, scripting language written in Go using the participle parser generator by Alec Thomas\textsuperscript{\cite{thomas_2021}}. For information on how to run the \verb|sttp| interpreter, check the \verb|README|. Below is the formal grammar definition of the language:

% \import{../specification_for_language}{specification_for_language_body.tex}

\cprotect\chapter{\verb|sttp| Examples}
\label{appendix:sttp-examples}

\cprotect\textit{Located in: \verb|src/_examples/example_XX|}

\verb|sttp| examples that are run as unit tests for the \verb|sttp| interpreter. Please read the \verb|README| to find out how to build/run the \verb|sttp| interpreter from source. The expected stdout, stderr, test output, and error output will be located within the example's directory, \textbf{if it has an output available}.

\cprotect\textit{Note: some of these examples require the echo-chamber web API to be running alongside the \verb|sttp| interpreter. This can be found in \verb|src/_examples/echo_chamber/main.js|, and can be run using \verb|node|.}

\section{Example 1 - Catch all}
\label{appendix:sttp-examples-1}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_01/example_01.sttp}

\section{Example 2 - JSONPath}
\label{appendix:sttp-examples-2}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_02/example_02.sttp}

\section{Example 3 - IfElifElse}
\label{appendix:sttp-examples-3}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_03/example_03.sttp}

\section{Example 4 - While}
\label{appendix:sttp-examples-4}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_04/example_04.sttp}

\section{Example 5 - For}
\label{appendix:sttp-examples-5}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_05/example_05.sttp}

\section{Example 6 - ForEach}
\label{appendix:sttp-examples-6}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_06/example_06.sttp}

\section{Example 7 - FunctionDefinition and FunctionCall}
\label{appendix:sttp-examples-7}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_07/example_07.sttp}

\section{Example 8 - Recursive FunctionCalls}
\label{appendix:sttp-examples-8}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_08/example_08.sttp}

\section{Example 9 - MethodCalls}
\label{appendix:sttp-examples-9}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_09/example_09.sttp}

\section{Example 10 - TryCatch}
\label{appendix:sttp-examples-10}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_10/example_10.sttp}

\section{Example 11 - Batch}
\label{appendix:sttp-examples-11}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_11/example_11.sttp}

\section{Example 12 - Free builtin}
\label{appendix:sttp-examples-12}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_12/example_12.sttp}

\section{Example 13 - Find builtins}
\label{appendix:sttp-examples-13}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_13/example_13.sttp}

\section{Example 14 - Escape characters}
\label{appendix:sttp-examples-14}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_14/example_14.sttp}

\section{Example 15 - Breaking and returning}
\label{appendix:sttp-examples-15}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_15/example_15.sttp}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}

\printbibheading
\printbibliography[keyword=cite,heading=subbibliography,title={Cited material}]%
\nocite{*}
\printbibliography[keyword=nocite,heading=subbibliography,title={Supplementary material}]

\end{document}

\end{article}
