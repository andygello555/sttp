\documentclass[]{full}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{caption}
\usepackage{import}
\usepackage[style=ieee]{biblatex}
\usepackage[table,xcdraw]{xcolor}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pmboxdraw}
% \usepackage{verbatim} % for verbatim environment and \verbatiminput
% \usepackage{sverb} % for \verbinput
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}

% \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
% \AfterEndEnvironment{minted}{\end{tcolorbox}}%

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2022}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count:

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 2022

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Motivations}
\label{chap:motivations}

Web APIs are in the background of most applications and services we use. Everything from requesting the weather in a certain country, accessing up to date exchange rate information, to accessing personal calendar information, can all be achieved through the use of specific web APIs.

\textit{A server side web API is an application programming interface that is hosted on a web server accessible via the HTTP protocol. Endpoints within a web API specify where an action or resource lies, creating a \textbf{directory like structure} of `methods'.}

The number of web APIs has risen substantially over the last decade and a half. \href{https://www.programmableweb.com/category/all/apis}{ProgrammableWeb}, cites over 24,000 APIs (as of January 2022). A large increase from 2013: 9000, and an even larger increase from 2005: 105\textsuperscript{\cite{duvander_2013}}.

\textit{Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites\textsuperscript{\cite{web_scraping_wikipedia_2022}}.}

Partly due to the ubiquity of web APIs, as well as my interest toward creating autonomous web-scraping solutions. I have gained a lot of experience using them, and have even developed a few of my own. Before beginning this project, I had been working on a large library of web scraping procedures, to track, scrape, and store information on several hundreds of applications on the popular PC video game e-tailer: \href{https://store.steampowered.com/}{Steam}. This was largely achieved by using Steam's Web API, but also by scraping data directly from webpages, dashboards, and portals. The data retrieved by said procedures would be stored in a database, accessible via a web API. Most of the endpoints within this API perform various complex manipulations and aggregations to return a representation of the data that is easier to handle for users. This interest soon stemmed into my professional life, when I was asked to implement this system on a larger scale for a indie video game publisher. Thus increasing the workload and data throughput of the server.

Soon, the complexity of the codebase spiralled out of control. The test suites that were written to check if the procedures were functioning properly, became large and unruly. Frequent and undocumented changes to the Steam Web API, would render some procedures out of action for several days. To deal with this issue, I moved the implementation of some of the test suites to \href{https://insomnia.rest/}{Insomnia} (a REST client that allows you to build test suites for web APIs). Whilst having an extensive feature-set for a REST client, Insomnia lacked control-flow constructs for complex request and response handling. Constructs such as conditionals, looping, and error handling, are missing/very hard to implement. Soon after, the tests written in Insomnia were abandoned in favour of refactored versions of the previous tests within the code base itself.

Due to this need of greater functionality, I propose a scripting language purposefully designed as a HTTP client and test suite first.

\begin{center}
\verb|sttp| \textit{(amalgamation of `scripting' and `HTTP')}
\end{center}

\verb|sttp| was made in order to test web APIs that have complex interaction flows, or APIs that are just black boxes. The main features that \verb|sttp| was designed in mind with are:

\begin{enumerate}
    \item \textbf{Builtin HTTP client}. There must be a way to make HTTP requests.
    \item \textbf{Concise, quick and manageable builtin testing}. Tests should be easily implementable and modifiable. There should also be a way of grouping tests for actions that access a similar resource. Just like how REST APIs are designed.
    \item \textbf{JSON values and JSONPath}. All values in \verb|sttp| should be parsable to JSON and back. As most web APIs default to JSON as their interchange format, it makes sense to treat all data as JSON. \textbf{JSONPath}, is a syntax for accessing JSON values in the similar vain of XPath for XML\textsuperscript{\cite{goessner_2007}}.
    \item \textbf{Executing HTTP requests concurrently}. Concurrency should be easy and encouraged.
    \item \textbf{Command line usage}. I regularly tinker and test endpoints on the command line. Thus I expect the \verb|sttp| interpreter to be able to be run from the command line. This means creating a \textbf{whitespace independent grammar} that allows for input to be typed on a single line.
    \item \textbf{Web scraping functionality}. Such as a HTML parser, tree search functions, and filtering.
\end{enumerate}

To achieve this, I decided to write an interpreter using Go\textsuperscript{\cite{the_go_programming_language}} and the participle parser generator\textsuperscript{\cite{thomas_2021}}. I chose Go as its accompanying toolset allows for quick testing and benchmarking. I knew this would be useful when developing the language and benchmarking the concurrency constructs within the language. This native tooling also allows for rapid development and less external dependencies. At the beginning of the project I was comfortable at writing code in Go, as I had used it for numerous other projects in the past.

I chose the participle parser generator, as it was (and still is) being actively developed, and had a plethora of examples available. It also has an interesting way of defining the accepted grammar for the generated parser. Encoding EBNF within the AST node type declarations, the instantiated versions of which will be returned by the generated parser (explained further whilst discussing the \hyperref[sec:four-function-calc]{four-function calculator}). However, the generated parsers are recursive descent parsers. This meant I had to design my language without any left-recursion. Thankfully, the iteration operator in participle's EBNF notation, solved some of the issues, such as left-associative operators.

\section{The Future}

As explained in the \hyperref[chap:motivations]{motivations introduction}, much of my professional life and pastimes involve creating and testing web APIs. Therefore, \verb|sttp| is something that I would hope to use in both domains. I plan on continuing development on \verb|sttp| in the background to add newer features that will solve issues that occur frequently in my work life. Go is also rising in popularity within the web API space, and now that I am fairly fluent in it, I hope to use it within the workplace soon.

As I enjoyed learning the theory behind programming language design and engineering as much as I enjoyed creating \verb|sttp|. I hope I can make better use of this knowledge in the appropriate field of work. I have found the material covered within \textit{CS3480: Software Language Engineering}, quite eye-opening as to the number of different Domain Specific Languages (DSL), in use and in development. There is a DSL for everything from CAD 3D modelling to programming robots\textsuperscript{\cite{nordmann_hochgeschwender_wrede_2014}}. A job within this area could have work that I find rewarding and interesting.

\chapter{How to read this report}

This report is split into two broad parts. The first reads as a quick introduction to web-APIs and how to use them, as well as how the \verb|sttp| programming language fits into this space. It also includes examples and explanations of how to program in \verb|sttp|, and outlines the problems that it solves. The second, reads as an in-depth technical overview of \verb|sttp|'s development with specific details on the data-structures and algorithms used. This section will dive into specific source-code listings within the interpreter, and it assumes an intermediate knowledge of programming in Go.

The reason behind this split was so that readers can get a reasonable understanding of how \verb|sttp| might work internally, through the real-world problems that it solves. It also enables those with more general expertise in computer science to get to grips with \verb|sttp| quicker.

\section{Specification}

The specification for \verb|sttp| can be found in \verb|reports/specification_for_language/|. This is to be read as a more in-depth user guide to \verb|sttp|. Throughout the report this specification might referenced, in which case it can be used to supplement the material within the report.

\cprotect\part{Meet \verb|sttp|}

\import{chapters}{3-web-apis.tex}

\import{chapters}{4-designing-rest-api.tex}

\import{chapters}{5-hello-sttp.tex}

\part{Technical}

To fully understand the technical information within this part, it is recommended that you first read through the sections on test programs. These will run through the functionality utilised by the participle parser generator library, as well as some of the general feature-set of Go that is heavily utilised in the \verb|sttp| interpreter.

\chapter{Test Programs}
\label{chap:test-programs}

Before development began I wrote a few test programs to get back up to speed with programming in Go, as well as familiarising myself with participle.

\import{sections}{2-1-four-func-calc.tex}

\import{sections}{2-2-regex-minimiser.tex}

\chapter{Development}
\label{chap:development}

\import{sections}{2-3-grammar-ast.tex}

\import{sections}{2-4-data-structures.tex}

\import{sections}{2-5-casting.tex}

\import{sections}{2-6-operators.tex}

\section{Evaluating AST nodes}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``Made final touches to interim report before handing in. Completed all operator actions as well as defining agnostic evaluation methods for all precedence levels. I also implemented assignment statements as well as if-elif-else statements. Along with JSONPath setting and getting. I had to rewrite my Heap data structure and my Value structure."}\\[0.5em]
        \tiny{11:51 am on December 6, 2021}
    \end{center}
\end{figure}
    
Each AST node within \verb|sttp| implements the \verb|evalNode| interface. This defines the \mintinline[breaklines]{go}{Eval(vm VM) (err error, result *data.Value)} instance method (among other things), that will be called on the root AST node (\verb|Program|) with a fresh \verb|VM| instance. The \verb|Eval| instance method of each lower AST node will be called as the interpreter executes a depth-first leftmost tree traversal; passing the \verb|VM| instance to each. The \verb|err| return parameter is used to `bubble' up an error/exception if one occurs in any of the AST nodes. This error will either float up to the \verb|Program| root, or to a \verb|TryCatch| AST node. The \verb|evalNode| interface was mainly implemented to improve readability and reduce complexity with the evaluation of AST nodes within \hyperref[sec:development-ast-nodes-expressions]{expression subtrees}.

Most AST node will be given a section for technical explanation below in the order that they were \textbf{first} implemented. Not all AST nodes warrant a complete technical breakdown. This is done for AST node's that have a fairly straightforward implementation, or do not warrant discussion. In these cases a reference to the appropriate file and line numbers in the code will be provided so that the code can be inspected easily.

% \import{sections}{2-7-1-jsonpath-assignment.tex}
\subsection{JSONPath and Assignment}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-2]}{\verb|src/_examples/example_02/example_02.sttp|}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: json path setter + assignment ast node
- Added beginnings of json path setters and getters (02/12/2021 - 12:30:37)
- Added some more eval referrers for different AST nodes (02/12/2021 - 12:31:03)
- Added the Current referrer to the CallStack interface which returns the topmost
  frame (02/12/2021 - 12:31:33)
- Added the Exception and JSONPathError RuntimeErrors (02/12/2021 - 12:31:55)
    \end{minted}
    \vspace{-1em}
    \tiny{December 2, 2021}
\end{center}
%TC:endignore

The \verb|src/parser/json_path.go| contains the \verb|Path| type that acts as an intermediate representation for JSONPath access and setting. Each segment of a JSONPath AST node has a correlated \verb|Convert| method which carries out this transformation. From there a \verb|Path| can be used to \verb|Get| and \verb|Set| values of the given value with the corresponding methods.

The \verb|Eval| method for the JSONPath AST node can be found in: \verb|src/parser/eval.go:863|, whereas the \verb|Eval| method for the Assignment AST node can be found at \verb|src/parser/eval.go:166|.

\import{sections}{2-7-2-expressions.tex}

% \import{sections}{2-7-3-if-elif-else.tex}

\subsection{If-Elif-Else}

\textit{Examples can be found in: }\cprotect{\hyperref[appendix:sttp-examples-3]}{\verb|src/_examples/example_03/example_03.sttp|}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}[breaklines]{markdown}
Language: Heap rework + Symbol -> Value + IfElifElse
- Reworked Heap datastructure (06/12/2021 - 02:57:30)
- Renamed Symbol to Value (06/12/2021 - 02:57:54)
- Refactored a lot of files to accomodate these 
  changes (06/12/2021 - 02:58:14)
- Implemented ifelifelse Eval referrer and added example
  code to test it (06/12/2021 - 03:57:36)
    \end{minted}
    \vspace{-1em}
    \tiny{December 6, 2021}
\end{center}
%TC:endignore

The \verb|Eval| method for the \verb|IfElifElse| AST node can be found in: \verb|src/parser/ast.go:304|.

% \import{sections}{2-7-4-iterations.tex}

% \import{sections}{2-7-5-functions.tex}

% \import{sections}{2-7-6-http-methods.tex}

% \import{sections}{2-7-7-testing.tex}

% \import{sections}{2-7-8-try-catch-throw.tex}

\import{sections}{2-7-9-batch-statement.tex}

% \import{sections}{2-7-10-builtins.tex}

\import{chapters}{7-evaluation.tex}

\import{chapters}{8-discussion.tex}

\import{chapters}{9-professional-issues.tex}

\appendix

\cprotect\chapter{\verb|sttp| Examples}
\label{appendix:sttp-examples}

\cprotect\textit{Located in: \verb|src/_examples/example_XX|}

\verb|sttp| examples that are run as unit tests for the \verb|sttp| interpreter. Please read the \verb|README| to find out how to build/run the \verb|sttp| interpreter from source. The expected stdout, stderr, test output, and error output will be located within the example's directory, \textbf{if it has an output available}.

\cprotect\textit{Note: some of these examples require the echo-chamber web API to be running alongside the \verb|sttp| interpreter. This can be found in \verb|src/_examples/echo_chamber/main.js|, and can be run using \verb|node|.}

\section{Example 1 - Catch all}
\label{appendix:sttp-examples-1}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_01/example_01.sttp}
%TC:endignore

\section{Example 2 - JSONPath}
\label{appendix:sttp-examples-2}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_02/example_02.sttp}
%TC:endignore

\section{Example 3 - IfElifElse}
\label{appendix:sttp-examples-3}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_03/example_03.sttp}
%TC:endignore

\section{Example 4 - While}
\label{appendix:sttp-examples-4}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_04/example_04.sttp}
%TC:endignore

\section{Example 5 - For}
\label{appendix:sttp-examples-5}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_05/example_05.sttp}
%TC:endignore

\section{Example 6 - ForEach}
\label{appendix:sttp-examples-6}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_06/example_06.sttp}
%TC:endignore

\section{Example 7 - FunctionDefinition and FunctionCall}
\label{appendix:sttp-examples-7}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_07/example_07.sttp}
%TC:endignore

\section{Example 8 - Recursive FunctionCalls}
\label{appendix:sttp-examples-8}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_08/example_08.sttp}
%TC:endignore

\section{Example 9 - MethodCalls}
\label{appendix:sttp-examples-9}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_09/example_09.sttp}
%TC:endignore

\section{Example 10 - TryCatch}
\label{appendix:sttp-examples-10}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_10/example_10.sttp}
%TC:endignore

\section{Example 11 - Batch}
\label{appendix:sttp-examples-11}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_11/example_11.sttp}
%TC:endignore

\section{Example 12 - Free builtin}
\label{appendix:sttp-examples-12}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_12/example_12.sttp}
%TC:endignore

\section{Example 13 - Find builtins}
\label{appendix:sttp-examples-13}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_13/example_13.sttp}
%TC:endignore

\section{Example 14 - Escape characters}
\label{appendix:sttp-examples-14}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_14/example_14.sttp}
%TC:endignore

\section{Example 15 - Breaking and returning}
\label{appendix:sttp-examples-15}
%TC:ignore
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_15/example_15.sttp}
%TC:endignore

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}

\printbibheading
\printbibliography[keyword=cite,heading=subbibliography,title={Cited material}]%
\nocite{*}
\printbibliography[keyword=nocite,heading=subbibliography,title={Supplementary material}]

\end{document}

\end{article}
