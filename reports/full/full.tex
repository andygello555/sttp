\documentclass[]{full}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{minted}
\usepackage{cprotect}
\usepackage{caption}
\usepackage{import}
\usepackage[style=ieee]{biblatex}
\usepackage[table,xcdraw]{xcolor}
\usepackage{tcolorbox}
\usepackage{etoolbox}
\usepackage{mathtools}
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}

% \BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
% \AfterEndEnvironment{minted}{\end{tcolorbox}}%

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2022}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count:

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 2022

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Motivations}
\label{chap:motivations}

\begin{definition}[Server side Web API]
    A server side web API is an application programming interface that is hosted on a web server accessible via the HTTP protocol. Endpoints within a web API specify where an action or resource lies, creating a \textbf{directory like structure} of `methods'.
\end{definition}

Web APIs are in the background of most applications and services we use. Everything from requesting the weather in a certain country, accessing up to date exchange rate information, to accessing personal calendar information, can all be achieved through the use of specific web APIs. The number of web APIs has risen substantially over the last decade and a half. \href{https://www.programmableweb.com/category/all/apis}{ProgrammableWeb}, cites over 24,000 APIs (as of January 2022). A large increase from 2013: 9000, and an even larger increase from 2005: 105\textsuperscript{\cite{duvander_2013}}.

\begin{definition}[Web Scraping]
    Web scraping, web harvesting, or web data extraction is data scraping used for extracting data from websites\textsuperscript{\cite{web_scraping_wikipedia_2022}}.
\end{definition}

Partly due to the ubiquity of web APIs, as well as my interest toward creating autonomous web-scraping solutions. I have gained a lot of experience using them, and have even developed a few of my own. Before beginning this project, I had been working on a large library of web scraping procedures, to track, scrape, and store information on several hundreds of applications on the popular PC video game e-tailer: \href{https://store.steampowered.com/}{Steam}. This was largely achieved by using Steam's Web API, but also by scraping data directly from webpages, dashboards, and portals. The data retrieved by said procedures would be stored in a database, accessible via a web API. Most of the endpoints within this API perform various complex manipulations and aggregations to return a representation of the data that is easier to handle for users. This interest soon stemmed into my professional life, when I was asked to implement this system on a larger scale for a indie video game publisher. Thus increasing the workload and data throughput of the server.

Soon, the complexity of the codebase spiralled out of control. The test suites that were written to check if the procedures were functioning properly, became large and unruly. Frequent and undocumented changes to the Steam Web API, would render some procedures out of action for several days. To deal with this issue, I moved the implementation of some of the test suites to \href{https://insomnia.rest/}{Insomnia} (a REST client that allows you to build test suites for web APIs). Whilst having an extensive feature-set for a REST client, Insomnia lacked control-flow constructs for complex request and response handling. Constructs such as conditionals, looping, and error handling, are missing/very hard to implement. Soon after, the tests written in Insomnia were abandoned in favour of refactored versions of the previous tests within the code base itself.

Due to this need of greater functionality, I propose a scripting language purposefully designed as a HTTP client and test suite first.

\begin{center}
\verb|sttp| \textit{(amalgamation of `scripting' and `HTTP')}
\end{center}

\verb|sttp| was made in order to test web APIs that have complex interaction flows, or APIs that are just black boxes. The main features that \verb|sttp| was designed in mind with are:

\begin{enumerate}
    \item \textbf{Builtin HTTP client}. There must be a way to make HTTP requests.
    \item \textbf{Concise, quick and manageable builtin testing}. Tests should be easily implementable and modifiable. There should also be a way of grouping tests for actions that access a similar resource. Just like how REST APIs are designed.
    \item \textbf{JSON values and JSONPath}. All values in \verb|sttp| should be parsable to JSON and back. As most web APIs default to JSON as their interchange format, it makes sense to treat all data as JSON. \textbf{JSONPath}, is a syntax for accessing JSON values in the similar vain of XPath for XML\textsuperscript{\cite{goessner_2007}}.
    \item \textbf{Executing HTTP requests concurrently}. Concurrency should be easy and encouraged.
    \item \textbf{Command line usage}. I regularly tinker and test endpoints on the command line. Thus I expect the \verb|sttp| interpreter to be able to be run from the command line. This means creating a \textbf{whitespace independent grammar} that allows for input to be typed on a single line.
    \item \textbf{Web scraping functionality}. Such as a HTML parser, tree search functions, and filtering.
\end{enumerate}

To achieve this, I decided to write an interpreter using Go\textsuperscript{\cite{the_go_programming_language}} and the participle parser generator\textsuperscript{\cite{thomas_2021}}. I chose Go as its accompanying toolset allows for quick testing and benchmarking. I knew this would be useful when developing the language and benchmarking the concurrency constructs within the language. This native tooling also allows for rapid development and less external dependencies. At the beginning of the project I was comfortable at writing code in Go, as I had used it for numerous other projects in the past.

I chose the participle parser generator, as it was (and still is) being actively developed, and had a plethora of examples available. It also has an interesting way of defining the accepted grammar for the generated parser. Encoding EBNF within the AST node type declarations, the instantiated versions of which will be returned by the generated parser (explained further whilst discussing the \hyperref[sec:four-function-calc]{four-function calculator}). However, the generated parsers are recursive descent parsers. This meant I had to design my language without any left-recursion. Thankfully, the iteration operator in participle's EBNF notation, solved some of the issues, such as left-associative operators.

\section{The Future}

As explained in the \hyperref[chap:motivations]{motivations introduction}, much of my professional life and pastimes involve creating and testing web APIs. Therefore, \verb|sttp| is something that I would hope to use in both domains. I plan on continuing development on \verb|sttp| in the background to add newer features that will solve issues that occur frequently in my work life. Go is also rising in popularity within the web API space, and now that I am fairly fluent in it, I hope to use it within the workplace soon.

As I enjoyed learning the theory behind programming language design and engineering as much as I enjoyed creating \verb|sttp|. I hope I can make better use of this knowledge in the appropriate field of work. I have found the material covered within \textit{CS3480: Software Language Engineering}, quite eye-opening as to the number of different Domain Specific Languages (DSL), in use and in development. There is a DSL for everything from CAD 3D modelling to programming robots\textsuperscript{\cite{nordmann_hochgeschwender_wrede_2014}}. A job within this area could have work that I find rewarding and interesting.

\section{How to read this report}

This report is split into two-broad parts. The first reads as a quick introduction to web-APIs and how to use them, as well as how the \verb|sttp| programming language fits into this space. It also includes examples and explanations of how to program in \verb|sttp|, and outlines the problems that it solves. The second, reads as an in-depth technical overview of \verb|sttp|'s development with specific details on the data-structures and algorithms used. This section will dive into specific source-code listings within the interpreter, and it assumes an intermediate knowledge of programming within Go.

The reason behind this split was so that readers can get a reasonable understanding of how \verb|sttp| might work internally, through the real-world problems that it solves. It also enables those with more general expertise in computer science to get to grips with \verb|sttp| quicker.

\cprotect\part{Meet \verb|sttp|}

\chapter{Web APIs and where to find them}

In this chapter we will discuss the types of web-APIs, give some introductory \verb|sttp| code, and create a small theoretical web API that serves as an interface for a \textbf{blog website}.

\section{Web-APIs}

One important disambiguation to establish before continuing with the report is what kind web APIs that we are going to focus on.

\subsection{Client side Web APIs}

When a web API is client side, it means that it is running directly within a user's web browser or HTTP client. The Mozilla Foundation \href{https://developer.mozilla.org/en-US/docs/Web/API}{outlines all of the client side web APIs} that can be used when developing a HTML5 application. These are \textbf{not} the web APIs that we will refer to for the rest of the report.

\subsection{Server side Web APIs}

As mentioned in the \hyperref[chap:motivations]{motivations} chapter, server side web APIs offer one-or-more user exposed endpoints that perform specific actions within a service. \cprotect\textbf{\verb|sttp| was written in order to test these actions}.

\cprotect\section{\verb|sttp| is a HTTP client}
\label{sec:meet-sttp-http-clients}

Server side web APIs require the use of a HTTP client to communicate with them. HTTP clients make and accept HTTP requests and responses. Examples of HTTP clients include: \href{https://github.com/curl/curl}{cURL}, \href{https://www.gnu.org/software/wget/}{Wget}, \href{https://httpie.io/}{HTTPie}, and web browsers. On its base level, \cprotect\textbf{\verb|sttp| is just a HTTP client} wrapped within an iterative/procedural programming language.

For instance, when visiting the domain: \verb|https://www.example.com/| within a web browser; the web browser will act as a HTTP client, requesting the resource found at that URL (this might be a webpage, CSV, PDF, JSON, etc.). Below shows some similar commands for retrieving this resource using the different HTTP clients mentioned above:

\begin{enumerate}
    \item cURL: \mintinline[breaklines]{sh}{curl https://www.example.com/}
    \item Wget: \mintinline[breaklines]{sh}{wget https://www.example.com/}
    \item HTTPie: \mintinline[breaklines]{sh}{http GET https://www.example.com/}
    \item \verb|sttp|: \verb|$GET("https://www.example.com/")|
\end{enumerate}

\section{Web APIs services}

Typically, when talking about server side web APIs we assume that a web API \textbf{talks to a service}. For example, a service could be a database of exchange rates. The web API for this service might have an \textbf{endpoint} consisting of the following URL path construction: \verb|/{from}/{to}|. Making a \verb|GET| request to the URL: \verb|/GBP/USD| (using a HTTP client) will return the exchange rate from GBP to USD for the previous day as a \verb|JSON| object.

This allows subscribers to these services to \textbf{access them without much knowledge of the internal system itself}. \textbf{Endpoints} is the term usually given for a URL schema with a specific action tied to it. Information pertaining to the request is usually encoded within the URL itself: \verb|/GBP/USD|, placed within the query parameters: \verb|/today?from=GBP&to=USD|, or placed in the body of the HTTP request itself (if the HTTP method allows it). These endpoints are then tied to certain actions within these services by the web API developers. Actions such as: usually getting, creating, updating, and deleting resources are common actions tied to external endpoints.

\section{Web API intricacies}

When web APIs are modelled for large and intricate services, the layout of the endpoints for them can become cluttered very quickly. Thus, web API developers usually find it necessary to follow a convention for defining these endpoints. These conventions define how a set of actions might be mapped onto a URL and HTTP request methods (GET, POST, PUT, ...). One of the most popular of these conventions at the moment is: REST. A web API is considered RESTful if it adhere to a set of principles\textsuperscript{\cite{richardson_ruby_2007}}. The most relevant of these, to the current discussion on endpoints, is the \textbf{uniform interface} principle. This enforces that all RESTful APIs must\textsuperscript{\cite{fielding_2000}}:

% https://archive.org/details/restfulwebservic00rich_0

\begin{enumerate}
    \item \textbf{Identify resources within endpoints that access that specific resource}. For instance, if the web API is an interface for a blogging service, and blog resources are identified by a \href{https://www.uuidgenerator.net/version4}{UUID4}, then the following URL path might be constructed to access the comments on a blog: \verb|/blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993/comments|.
    \item \textbf{Manipulate resources through representations of the internal structure of said resources}. Continuing the blogging service example, when requesting a specific blog this might fetch a row from the service's database and then \textbf{serialise} it into a media type such as \verb|JSON|. For example, the request \verb|GET /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| might return the following \verb|JSON| data:
    \begin{minted}{json}
{
    "id": "1a88249b-4b93-4b7f-b38c-d967af5a7993",
    "name": "RESTful APIs",
    "author": "Jane Doe",
    "tags": [
        "Web APIs",
        "APIs",
        "REST"
    ]
}    
    \end{minted}
    This serialised blog returns all the data necessary to manipulate it. For instance, to update the name of the blog, the author might send the following request: \\\verb|PUT /blogs/1a88249b-4b93-4b7f-b38c-d967af5a7993| with the body: \mintinline[breaklines]{json}{{"name": "RESTful Web APIs"}}. \cprotect\textit{Note how the body of the request is just a partial version of the data returned by \verb|GET|ting the same endpoint}.
\end{enumerate}

Hopefully this gives some indication as to how web APIs are created and used to access services. In the following chapter I will create an example web API that will be used throughout the first part of this report.

\chapter{Theorising a simple REST web API}

In this chapter we will create a theoretical REST web API to access a blogging service (similar to the one used as an example at the end of the last). This example web API will then be used throughout the first part as a common example.

\section{Formal definition of the blogging service}

The blogging service in question has three different resources, all of which are stored in their own tables within an internal database. This database \textbf{cannot} be accessed by end-users of the blogging service.

\begin{enumerate}
    \item \textbf{Topics}: each topic has a \textbf{unique ID}, the \textbf{number of blogs residing within it}, and a \textbf{name}.
    \item \textbf{Blogs}: each blog has a \textbf{unique ID}, a \textbf{name}, a \textbf{body}, the \textbf{author's name}, a \textbf{link to the topic it resides in}, and a \textbf{list of tags}.
    \item \textbf{Comments}: each comment has a \textbf{unique ID}, a \textbf{body}, the \textbf{commentor's name}, and the \textbf{link to a blog}.
\end{enumerate}

It is worth noting that although these resources describe parts of the internal database. It might still might mean that when requesting said resources, the server will add additional properties to them. For instance, with the \textbf{Topics} resource, storing the number of blogs within that topic within the database could be seen as inneligant. This is because each time a blog is created, its corresponding topic must have its blog counter incremented within the database. Instead, one might \textbf{bind this blog counter information when the request is being handled}. This is much more robust, and means less database interaction overall.

We will assume that the API for this service serves its responses as, and accepts its requests in \verb|JSON|. The \verb|JSON| serialised versions of these resources are constructed from the properties of that specific resource, where the keys of the object are snake-cased versions of the property name. \verb|JSON| is a very popular choice of media type for REST APIs in particular.

\section{The actions that are defined for users of the service}

A user of the service must be able to perform the following actions. Each action has been grouped under its relevant resource type, and assigned an endpoint and HTTP method.

For simplicity, we will assume that all users have permission to do everything. In a production web API, this would not be the case. Tokens would be used to authenticate the user and authorised using some sort of access control list.

\begin{itemize}
    \item Topics
    \begin{itemize}
        \item List all topics: \verb|GET /topics|
        \item Create a topic: \verb|POST /topics|
        \item Get a topic: \verb|GET /topics/{topic_id}|
        \item Update a topic: \verb|PUT /topics/{topic_id}|
        \item Delete a topic: \verb|DELETE /topics/{topic_id}|
        \item Get the top 10 topics by the number of blogs within them: \verb|GET /topics/top|
        \item Get the blogs for a topic: \verb|GET /topics/{topic_id}/blogs|
    \end{itemize}
    \item Blogs
    \begin{itemize}
        \item List all blogs: \verb|GET /blogs|
        \item Create a blog: \verb|POST /blogs|
        \item Get a blog: \verb|GET /blogs/{blog_id}|
        \item Update a blog: \verb|PUT /blogs/{blog_id}|
        \item Delete a blog: \verb|DELETE /blogs/{blog_id}|
        \item Get the comments for a blog: \verb|GET /blogs/{blog_id}/comments|
    \end{itemize}
    \item Comments
    \begin{itemize}
        \item Create a comment: \verb|POST /comments|
        \item Get a comment: \verb|GET /comments/{comment_id}|
        \item Update a comment: \verb|PUT /comments/{comment_id}|
        \item Delete a comment: \verb|DELETE /comments/{comment_id}|
    \end{itemize}
\end{itemize}

By splitting our endpoints by resource, we can more efficiently communicate the different parts of the API. This makes using it easier.

\section{How would you use this API?}

This API does not make much sense as a standalone system. However, it makes more sense as a server application in a client-server architecture. By this I mean that the client application could be a HTTP client, or even another web server. In the case of a blogging service, it would make sense for there to be a seperate web server that hosts a set of webpages. These webpages then make requests to the web API to manipulate the service. This external facing web server is usually known as the `\textbf{frontend}', whereas the web API, along with the internal database, is known as the `\textbf{backend}'.

Whether or not to restrict this web API completely to the \textbf{frontend} for security, or to make it publicly available so that users can programmatically utilise the service, is ultimately up to the maintainers. Personally, in this situation, I would restrict access to the web API to just the frontend web server in order to avoid user spam of the creation endpoints.

\subsection{Some example HTTP requests using HTTPie}

I've chosen HTTPie as a HTTP client for these examples as the commands themselves are similar to how a raw HTTP request is structured. For more information on how to use HTTPie the documentation can be found \href{https://httpie.io/docs/cli/examples}{here}.

\cprotect\textit{These examples presume that the web API is hosted on a web server with the domain: \verb|example.com|.}

\begin{enumerate}
    \item Create a new topic on `Web APIs':
    \begin{minted}[breaklines]{sh}
http POST https://example.com/topics name='Web APIs' 
    \end{minted}
    Usually after creating a resource, the serialised version of that resource is returned back to the user.
    \begin{minted}[breaklines]{json}
{
    "id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "blog_count": 0,
    "name": "Web APIs"
}
    \end{minted}
    \item Create a new blog for the topic we have just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/blogs name='RESTful APIs' body='Blah Blah' author='Jane Doe' tags:='["Web APIs", "APIs", "REST"]' topic_id='26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3'
    \end{minted}
    Again returning back a serialised version of the resource:
    \begin{minted}[breaklines]{json}
{
    "id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "name": "RESTful APIs",
    "body": "Blah Blah",
    "author": "Jane Doe",
    "topic_id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "topic_url": "https://example.com/topics/26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "tags": ["Web APIs", "APIs", "REST"]
}
    \end{minted}
    \item We can then add a comment to the blog that was just created:
    \begin{minted}[breaklines]{sh}
http POST https://example.com/comments body='Great blog!' author='John Doe' blog_id='44e8b997-a3be-4813-b439-efd2a9d3ca10'
    \end{minted}
    The created comment\dots
    \begin{minted}[breaklines]{json}
{
    "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
    "body": "Great blog!",
    "author": "John Doe",
    "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
}
    \end{minted}
    \item Fetching the comments for a blog will return a list of serialised comment objects:
    \begin{minted}[breaklines]{sh}
http GET https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10/comments
    \end{minted}
    \begin{minted}[breaklines]{json}
[
    {
        "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
        "body": "Great blog!",
        "author": "John Doe",
        "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
        "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
    }
]
    \end{minted}
\end{enumerate}

How does \verb|sttp| fit into this equation?

\cprotect\chapter{Hello \verb|sttp|}

\begin{center}
    \textit{How would someone go about maintaining, testing, and extending the web API described above?}
\end{center}

This question might be asked when the project passes hands or a new developer is brought in who needs to be onboarded quickly. A rudimentary answer to this question might be to create test scripts using the command-line HTTP clients discussed in \hyperref[sec:meet-sttp-http-clients]{chapter 2}. However, from experience, this soon becomes quite unweildy as you need to create a test runner that crawls a given directory structure, or worse yet, whenever a new test needs to be added the whole test runner needs to be rewritten.

\begin{center}
    \textit{Is there another solution?}
\end{center}

Yes. As server side web APIs became more popular, many other people experienced similar problems with conventional HTTP clients. API clients are HTTP clients that allow the user to not only make HTTP requests, but to test specific endpoints, and sometimes even to design entire APIs. Although these API clients are feature rich, they lack the control flow available when using just scripting languages. \verb|sttp| hopes to be the API client/HTTP client/scripting language that fits between these two domains.

In the following section I will give a rough overview on the look-and-feel of the \verb|sttp| language. This is so that when explaining how \verb|sttp| would be used to \hyperref[sec:hello-sttp-using-sttp-to-test]{test web APIs}, the language won't seem as alien.

\cprotect\section{What does \verb|sttp| look like?}

\verb|sttp| is an interpreted imperative/procedural programming language that is dynamically-typed. The native types in \verb|sttp| are exactly similar to the ones used in the JSON interchange format:

\begin{verbatim}
string = "this is a string";
number = 1.23;  // 123 is also a number
boolean = true;
array = [1, "2", [3]];
object = {"hello": "world", "pi": 3.142};
n = null;
\end{verbatim}

\begin{itemize}
    \item \textbf{Strings}: sequences of characters surrounded by double quotes.
    \item \textbf{Numbers}: both integers and real numbers.
    \item \textbf{Booleans}: either \verb|false|, or \verb|true|.
    \item \textbf{Arrays}: an unbounded list of elements that can take any type, enclosed within square braces. Zero-indexed.
    \item \textbf{Objects}: a set of key-value pairs enclosed within curly braces. Keys must be String values.
    \item \textbf{Null}: \verb|null| is falsy (evaluates to \verb|false|) value that indicates an empty value.
    \item Along with the types defined within the \verb|JSON| specification, we also have the additional \textbf{Function} type that represents the `pointer' to a function definition.
    \begin{verbatim}
// More on this later...
function foo()
    return "bar";
end
func = foo;    
    \end{verbatim}
\end{itemize}

Compound statements, that take a nested `block', such as \verb|if|, \verb|while|, and \verb|for| are all terminated using the \verb|end| keyword, reminscient to Lua. Statements are seperated by semicolons, and functions are invoked by suffixing the function's path with a \verb|$| character. A comment is any line beginning with two forward slashes: \verb|//|. \verb|sttp| is whitespace independent, meaning that a program can be written on a single line. This is useful for quick prototyping through the command-line.

\subsection{JSONPath}

Variable assignment and dereference is achieved through JSONPath-like syntax. JSONPath is a syntax which can describe the path to any value within a \verb|JSON| Object, Array, or String. It is reminiscent to member access within Javascript.

\begin{verbatim}
// We define a variable foo, holding an Object value...
foo = {
    "array": [1, "2", [3]],
    "bar": "baz",
    "pi": 3.142
};

// If we wanted to print the 3rd element from the array
// with the key: "array", within the variable foo...
$print(foo.array[2]);

// We could also do...
$print(foo["array"][2]);

// Or even...
$print(foo[0][2]);

// All Objects in sttp are ordered lexicographically by
// their keys. This allows you to use integer indices to
// access values within Objects.
\end{verbatim}

Note the three ways of accessing a named property within an Object: \verb|.property|, \verb|["property"]|, or \verb|[i]|; where \verb|i| is the lexicographical index of the property to access in relation to the other keys.

Aside from simple member access, each property (\verb|.property|), or pair of square braces (\verb|[...]|), can be followed by a filter block. This is a block of \verb|sttp| code that will be run against each element of value currently pointed to by the path. If this block returns a truthy value for an element, then that element will be added to a resulting Array. Otherwise, returning a falsy value will not add that element. Filter blocks are enclosed between two triple backticks: \verb|```...```|.

Each time a filter block is run against an element within the value, the variable \verb|curr| is set. \verb|curr| is an Object that has a \verb|key| key, and a \verb|value| key.

\verb|key| stores the key of the currently iterated element within the value that is being iterated over. This will be an index when iterating over a String, or an Array, and a key when iterating over Objects.

\verb|value| stores the value of the currently iterated element within the value that is being iterated over. This can be any one of \verb|sttp|'s native types.

\begin{verbatim}
// If "foo" stores the value in the previous example...

// This will print the 3rd element from the value of the
// "array" key within foo. Note the final index access 
// after the filter to select the first element from the
// result Array.
$print(foo.array```
    return curr.key == 2;
```[0]);
\end{verbatim}

The examples up until now have been showcasing dereferencing variables via JSONPath, but \textbf{what if you want to assign a variable?} When it comes to assignment, \verb|sttp| employs a technique that (from what I can tell) is unique to \verb|sttp| alone. This technique is something that I've dubbed: \textbf{sparse-fill}. It allows Objects, Arrays, and Strings to be dynamically extended arbitrarily deep. For example:

\begin{verbatim}
foo = {"pi": 3.142};

// This will create the "bar" key within "foo"...
foo.bar = "foo bar";
// Same as: foo["bar"]

// This will create the "baz" key within a newly
// created Object residing within "bar"'s value
// within foo...
foo.bar.baz = "foo bar baz";
// Same as: foo["bar"]["baz"], foo.bar["baz"], ...

// But what about the value that was assigned to
// foo.bar? Don't worry it's still there...
$print(foo);

// The above print would output:
// {
//     "bar": {
//         "": "foo bar",
//         "baz": "foo bar baz"
//     },
//     "pi": 3.142
// }

// What are the ways of retrieving the old value
// of foo.bar?
$print(foo.bar[""]);
// Or...
$print(foo.bar[0]);
\end{verbatim}

Notice somethings interesting happens when sparsely filling \verb|foo.bar.baz|, when \verb|foo.bar| is already set to be a String. In this case, the next property within the JSONPath is accessing an Object key: \verb|.baz|, so the value initially stored at \verb|foo.bar| is moved to be the value of the empty string key (\verb|""|) within a `new' Object. There are two takeaways from this:

\begin{enumerate}
    \item When sparsely-filling a value, the next property in the JSONPath signifies what value will be created at that point.
    \begin{itemize}
        \item If the next property is a String index (\verb|["property"]|) or an Object key (\verb|.property|), then an Object will be created.
        \begin{enumerate}
            \item If a value already resides at that path, then it will be placed as a value of the empty string key (\verb|""|) within this newly created Object.
            \item This is done so that the old value can be retrieved by either a zero index (\verb|[0]|), as an \textbf{empty String will always be lexicographically first}, or by using a String index (\verb|[""]|).
        \end{enumerate}
        \item If the next property is a integer index (square braces container an integer), and the value to be accessed is not an Object, Array, or String, then an Array will be created.
        \begin{enumerate}
            \item If a value already resides at that path, then it will be placed in the position one index after the one being accessed.
            \item When creating a new Array, and accessing an element greater than 0, \verb|null|s will be inserted up until the accessed value.
            \begin{verbatim}
foo = {"pi": 3.142};
foo.pi[3] = "not pi";
$print(foo);
// The above print would output:
// {
//     "pi": [
//         null,
//         null,
//         null,
//         "not pi",
//         3.142
//     ]
// }
            \end{verbatim}
        \end{enumerate}
    \end{itemize}
    \item JSONPath assignment is very \textbf{permissive} in what it can do, and will \textbf{rarely throw an error}. This is was one of the main design philosophies when creating \verb|sttp|.
\end{enumerate}

JSONPath assignment on String values also has an interesting behaviour, and you can achieve some pretty complex String formatting by using it.

\begin{verbatim}
foo = "foo";

// Concatenation...
foo[3] = "bar";
$print(foo);
// Outputs: foobar

// Concatenating with whitespace...
foo[4] = "bar";
$print(foo);
// Outputs: foo bar

// Replacing characters with Strings...
foo[0] = "bo";
$print(foo);
// Outputs: booo
\end{verbatim}

There are quite a lot of intricacies when it comes to JSONPath assignment and dereferencing within \verb|sttp|, and not all of it will be covered in the scope of this part.

\subsection{Expressions}

\subsection{A note on Functions}

\subsection{Method Calls (HTTP requests)}

\cprotect\section{Using \verb|sttp| to test web APIs}
\label{sec:hello-sttp-using-sttp-to-test}

\part{Technical}

To fully understand the technical information within this part, it is recommended that you first read through the sections on test programs. These will run through the functionality utilised by the participle parser generator library, as well as some of the general feature-set of Go that is heavily utilised in the \verb|sttp| interpreter.

\chapter{Development}
\label{chap:development}

Before development began I wrote a few test programs to get back up to speed with programming in Go, as well as familiarising myself with participle.

\import{sections}{2-1-four-func-calc.tex}

\import{sections}{2-2-regex-minimiser.tex}

\import{sections}{2-3-grammar-ast.tex}

\import{sections}{2-4-data-structures.tex}

\import{sections}{2-5-casting.tex}

\import{sections}{2-6-operators.tex}

\section{Evaluating AST nodes}

\begin{figure}[H]
    \begin{center}
        \textbf{Diary Entry}\\[0.5em]
        \textit{``Made final touches to interim report before handing in. Completed all operator actions as well as defining agnostic evaluation methods for all precedence levels. I also implemented assignment statements as well as if-elif-else statements. Along with JSONPath setting and getting. I had to rewrite my Heap data structure and my Value structure."}\\[0.5em]
        \tiny{11:51 am on December 6, 2021}
    \end{center}
\end{figure}
    
Each AST node within \verb|sttp| implements the \verb|evalNode| interface. This defines the \mintinline[breaklines]{go}{Eval(vm VM) (err error, result *data.Value)} instance method (among other things), that will be called on the root AST node (\verb|Program|) with a fresh \verb|VM| instance. The \verb|Eval| instance method of each lower AST node will be called as the interpreter executes a depth-first leftmost tree traversal; passing the \verb|VM| instance to each. The \verb|err| return parameter is used to `bubble' up an error/exception if one occurs in any of the AST nodes. This error will either float up to the \verb|Program| root, or to a \verb|TryCatch| AST node. The \verb|evalNode| interface was mainly implemented to improve readability and reduce complexity with the evaluation of AST nodes within \hyperref[sec:development-ast-nodes-expressions]{expression subtrees}.

\import{sections}{2-7-1-jsonpath-assignment.tex}

\import{sections}{2-7-2-expressions.tex}

\import{sections}{2-7-3-if-elif-else.tex}

\import{sections}{2-7-4-iterations.tex}

\import{sections}{2-7-5-functions.tex}

\import{sections}{2-7-6-http-methods.tex}

\import{sections}{2-7-7-testing.tex}

\import{sections}{2-7-8-try-catch-throw.tex}

\import{sections}{2-7-9-batch-statement.tex}

\import{sections}{2-7-10-builtins.tex}

\import{chapters}{3-evaluation.tex}

\import{chapters}{4-discussion.tex}

\import{chapters}{5-professional-issues.tex}

%%%%%%%%%%%%%%%%%%%%%%
%%% sttp Specification

\appendix

\cprotect\chapter{\verb|sttp| Specification}
\label{appendix:sttp-specification}

\verb|sttp| (amalgamation of \textit{scripting} and \textit{HTTP}) is a dynamically typed, interpreted, scripting language written in Go using the participle parser generator by Alec Thomas\textsuperscript{\cite{thomas_2021}}. For information on how to run the \verb|sttp| interpreter, check the \verb|README|. Below is the formal grammar definition of the language:

\import{../specification_for_language}{specification_for_language_body.tex}

\cprotect\chapter{\verb|sttp| Examples}
\label{appendix:sttp-examples}

\cprotect\textit{Located in: \verb|src/_examples/example_XX|}

\verb|sttp| examples that are run as unit tests for the \verb|sttp| interpreter. Please read the \verb|README| to find out how to build/run the \verb|sttp| interpreter from source. The expected stdout, stderr, test output, and error output will be located within the example's directory, \textbf{if it has an output available}.

\cprotect\textit{Note: some of these examples require the echo-chamber web API to be running alongside the \verb|sttp| interpreter. This can be found in \verb|src/_examples/echo_chamber/main.js|, and can be run using \verb|node|.}

\section{Example 1 - Catch all}
\label{appendix:sttp-examples-1}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_01/example_01.sttp}

\section{Example 2 - JSONPath}
\label{appendix:sttp-examples-2}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_02/example_02.sttp}

\section{Example 3 - IfElifElse}
\label{appendix:sttp-examples-3}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_03/example_03.sttp}

\section{Example 4 - While}
\label{appendix:sttp-examples-4}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_04/example_04.sttp}

\section{Example 5 - For}
\label{appendix:sttp-examples-5}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_05/example_05.sttp}

\section{Example 6 - ForEach}
\label{appendix:sttp-examples-6}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_06/example_06.sttp}

\section{Example 7 - FunctionDefinition and FunctionCall}
\label{appendix:sttp-examples-7}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_07/example_07.sttp}

\section{Example 8 - Recursive FunctionCalls}
\label{appendix:sttp-examples-8}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_08/example_08.sttp}

\section{Example 9 - MethodCalls}
\label{appendix:sttp-examples-9}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_09/example_09.sttp}

\section{Example 10 - TryCatch}
\label{appendix:sttp-examples-10}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_10/example_10.sttp}

\section{Example 11 - Batch}
\label{appendix:sttp-examples-11}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_11/example_11.sttp}

\section{Example 12 - Free builtin}
\label{appendix:sttp-examples-12}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_12/example_12.sttp}

\section{Example 13 - Find builtins}
\label{appendix:sttp-examples-13}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_13/example_13.sttp}

\section{Example 14 - Escape characters}
\label{appendix:sttp-examples-14}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_14/example_14.sttp}

\section{Example 15 - Breaking and returning}
\label{appendix:sttp-examples-15}
\inputminted[autogobble, breaklines, tabsize=4]{text}{../../src/_examples/example_15/example_15.sttp}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}

\printbibheading
\printbibliography[keyword=cite,heading=subbibliography,title={Cited material}]%
\nocite{*}
\printbibliography[keyword=nocite,heading=subbibliography,title={Supplementary material}]

\end{document}

\end{article}
