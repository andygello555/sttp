\chapter{Designing a simple REST web API}
\label{chap:designing-rest-api}

In this chapter we will design an example REST web API to access a blogging service (similar to the one used as an example at the end of the last). This web API will then be used throughout the first part as a common example.

\section{The blogging service}
\label{sec:designing-rest-api-blogging-service}

The blogging service in question has three different resources, all of which are stored in their own tables within an internal database. This database \textbf{cannot} be accessed by end-users of the blogging service.

\begin{enumerate}
    \item \textbf{Topics}: each topic has a \textbf{unique ID}, the \textbf{number of blogs residing within it}, and a \textbf{name}.
    \item \textbf{Blogs}: each blog has a \textbf{unique ID}, a \textbf{name}, a \textbf{body}, the \textbf{author's name}, a \textbf{link to the topic it resides in}, and a \textbf{list of tags}.
    \item \textbf{Comments}: each comment has a \textbf{unique ID}, a \textbf{body}, the \textbf{commentor's name}, and the \textbf{link to a blog}.
\end{enumerate}

It is worth noting that although these resources describe parts of the internal database. It might still might mean that when requesting said resources, the server will add additional properties to them. For instance, with the \textbf{Topics} resource, storing the number of blogs within that topic within the database could be seen as inneligant. This is because each time a blog is created, its corresponding topic must have its blog counter incremented within the database. Instead, one might \textbf{bind this blog counter information when the request is being handled}. This is much more robust, and means less database interaction overall.

We will assume that the API for this service serves its responses as, and accepts its requests in \verb|JSON|. The \verb|JSON| serialised versions of these resources are constructed from the properties of that specific resource, where the keys of the object are snake-cased versions of the property name. \verb|JSON| is a very popular choice of media type for REST APIs in particular.

\section{Defining the actions and endpoints for the service}

A user of the service must be able to perform the following actions. Each action has been grouped under its relevant resource type, and assigned an endpoint and HTTP method.

For simplicity, we will assume that all users have permission to do everything. In a production web API, this would not be the case. Tokens would be used to authenticate the user and authorised via an access control list.

\begin{itemize}
    \item Topics
    \begin{itemize}
        \item List all topics: \verb|GET /topics|
        \item Create a topic: \verb|POST /topics|
        \item Get a topic: \verb|GET /topics/{topic_id}|
        \item Update a topic: \verb|PUT /topics/{topic_id}|
        \item Delete a topic: \verb|DELETE /topics/{topic_id}|
        \item Get the top 10 topics by the number of blogs within them: \verb|GET /topics/top|
        \item Get the blogs for a topic: \verb|GET /topics/{topic_id}/blogs|
    \end{itemize}
    \item Blogs
    \begin{itemize}
        \item List all blogs: \verb|GET /blogs|
        \item Create a blog: \verb|POST /blogs|
        \item Get a blog: \verb|GET /blogs/{blog_id}|
        \item Update a blog: \verb|PUT /blogs/{blog_id}|
        \item Delete a blog: \verb|DELETE /blogs/{blog_id}|
        \item Get the comments for a blog: \verb|GET /blogs/{blog_id}/comments|
    \end{itemize}
    \item Comments
    \begin{itemize}
        \item Create a comment: \verb|POST /comments|
        \item Get a comment: \verb|GET /comments/{comment_id}|
        \item Update a comment: \verb|PUT /comments/{comment_id}|
        \item Delete a comment: \verb|DELETE /comments/{comment_id}|
    \end{itemize}
\end{itemize}

By splitting our endpoints by resource, we can more efficiently communicate the different parts of the API. This makes developing it, using it, and testing it easier.

\section{How would you use this API?}

This API does not make much sense as a standalone system. However, it makes more sense as a server application in a client-server architecture. By this I mean that the client application could be a HTTP client, or even another web server. In the case of a blogging service, it would make sense for there to be a seperate web server that hosts a set of webpages. These webpages then make requests to the web API to manipulate the service. This external facing web server is usually known as the `\textbf{frontend}', whereas the web API, along with the internal database, is known as the `\textbf{backend}'.

Whether or not to restrict this web API completely to the \textbf{frontend} for security, or to make it publicly available so that users can programmatically utilise the service, is ultimately up to the maintainers. Personally, in this situation, I would restrict access to the web API to just the frontend web server in order to avoid user spam of the creation endpoints.

\subsection{Some example HTTP requests using HTTPie}

I've chosen HTTPie as a HTTP client for these examples as the commands themselves are similar to how a raw HTTP request is structured. For more information on how to use HTTPie the documentation can be found \href{https://httpie.io/docs/cli/examples}{here}.

\cprotect\textit{These examples presume that the web API is hosted on a web server with the domain: \verb|example.com|.}

\begin{enumerate}
    \item Create a new topic on `Web APIs':
%TC:ignore
    \begin{minted}[breaklines]{sh}
http POST https://example.com/topics name='Web APIs' 
    \end{minted}
%TC:endignore
    Usually after creating a resource, the serialised version of that resource is returned back to the user.
%TC:ignore
    \begin{minted}[breaklines]{json}
{
    "id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "blog_count": 0,
    "name": "Web APIs"
}
    \end{minted}
%TC:endignore
    \item Create a new blog for the topic we have just created:
%TC:ignore
    \begin{minted}[breaklines]{sh}
http POST https://example.com/blogs name='RESTful APIs' body='Blah Blah' author='Jane Doe' tags:='["Web APIs", "APIs", "REST"]' topic_id='26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3'
    \end{minted}
%TC:endignore
    Again returning back a serialised version of the resource:
%TC:ignore
    \begin{minted}[breaklines]{json}
{
    "id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "name": "RESTful APIs",
    "body": "Blah Blah",
    "author": "Jane Doe",
    "topic_id": "26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "topic_url": "https://example.com/topics/26cfa9cc-d86f-4361-b1f8-138ec7e7bdd3",
    "tags": ["Web APIs", "APIs", "REST"]
}
    \end{minted}
%TC:endignore
    \item We can then add a comment to the blog that was just created:
%TC:ignore
    \begin{minted}[breaklines]{sh}
http POST https://example.com/comments body='Great blog!' author='John Doe' blog_id='44e8b997-a3be-4813-b439-efd2a9d3ca10'
    \end{minted}
%TC:endignore
    The created comment\dots
%TC:ignore
    \begin{minted}[breaklines]{json}
{
    "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
    "body": "Great blog!",
    "author": "John Doe",
    "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
    "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
}
    \end{minted}
%TC:endignore
    \item Fetching the comments for a blog will return a list of serialised comment objects:
%TC:ignore
    \begin{minted}[breaklines]{sh}
http GET https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10/comments
    \end{minted}
%TC:endignore
%TC:ignore
    \begin{minted}[breaklines]{json}
[
    {
        "id": "6aaa9fce-1340-4463-923b-cfe9217980a0",
        "body": "Great blog!",
        "author": "John Doe",
        "blog_id": "44e8b997-a3be-4813-b439-efd2a9d3ca10",
        "blog_url": "https://example.com/blogs/44e8b997-a3be-4813-b439-efd2a9d3ca10"
    }
]
    \end{minted}
%TC:endignore
\end{enumerate}

We have seen how to construct and use RESTful web APIs, but how does \verb|sttp| fit into this domain?
