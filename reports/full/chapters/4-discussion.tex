\chapter{Discussion on recursive descent parser generators}
\label{chap:discussion}

\verb|sttp| scripts are parsed using a recursive descent parser generated by the participle parser generator. Therefore, the grammar of \verb|sttp| is right-recursive, as opposed to left-recursive. A grammar is left-recursive if it has a non-terminal $A$ such that there is a derivation sequence $A \stackrel{\mathclap{\normalfont\mbox{+}}}{\Rightarrow} A \alpha$ for some string $\alpha$. Left recursion causes recursive descent to fall into an infinite loop due to the parse tree being constructed in a depth-first leftmost fashion\textsuperscript{\cite{scott_johnstone_1998}}.

Many recursive descent parser generators, participle included, can detect left-recursion within a grammar using a left-recursion detection algorithm. This works by checking if each production rule is \textbf{directly left-recursive}, by checking if the leftmost non-terminal on the RHS is the same as the non-terminal on the LHS. It then recursively checks each production rule of every non-terminal within that production rule for \textbf{indirect left-recursion}.

Even thought left-recursion algorithms, such as left-factoring, exist; many recursive descent parser generators, participle included, do not implement them. This might be because it is computationally expensive, or because it introduces extra production rules not in the original grammar.

Most of the grammars for modern programming languages are formally left-recursive. This is because most operations are left-associative (evaluated from left to right). Left-associative operators within grammars are left-recursive because, if the leftmost subtrees of the operations need to be evaluated first, this requires the grammar to introduce a production rule for that operator with a non-terminal on the left of the RHS.

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
                        E ::= T | E "+" T
                        T ::= F | F "**" T
                        F ::= Num | "(" E ")"
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \cprotect\caption{\label{fig:4.1}Here the \verb|+| operator is left-associative, and \verb|**| is right-associative. \verb|E ::= E "+" T| is left-recursive.}
\end{figure}

Fortunately, because participle uses EBNF, it means that I could encode left-associative operators within the \verb|sttp| grammar fairly easily. Using iteration instead of recursion can remove left-recursion from the grammar\textsuperscript{\cite{pattis_2021}}.

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
                        E ::= T { "+" T }
                        T ::= F [ "**" T ]
                        F ::= Num | "(" E ")"
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \caption{\label{fig:4.2}The grammar in \hyperref[fig:4.1]{fig. 4.1} rewritten with the EBNF to remove left recursion.}
\end{figure}

This will affect the produced parse tree as this will create a child for each repetition that is found in the input string. For example, for the given input string: \verb|1 + 2 + 3 ** 4|, the following derivation tree is created\textsuperscript{\cite{scott_johnstone_1998}}.

\begin{center}
    \begin{forest}
        for tree={
            if n children=0{
                font=\itshape,
            }{},
            }
            [$E$
                [$T$
                    [$F$
                        [Num: $1$]
                    ]
                ]
                [$+$]
                [$T$
                    [$F$
                        [Num: $2$]
                    ]
                ]
                [$+$]
                [$T$
                    [$F$
                        [Num: $3$]
                    ]
                    [{$**$}]
                    [$T$
                        [$F$
                            [Num: $4$]
                        ]
                    ]
                ]
            ]
    \end{forest}
\end{center}

Another quirk of \verb|sttp|'s grammar is that the precedence of operators is encoded within the grammar itself using grammar rules rather than after the parse tree is produced. This was done so that the precedence levels could be easily read from the grammar specification. However, doing so might have an impact on performance. This is because recursive descent expression parsers produce parse trees proportional in complexity to the number of operators supported, which leads to high memory usage\textsuperscript{\cite{bendersky_2012}}.

If parsing time or memory usage grows too great in the future, this is something that I would want to change within \verb|sttp|. If this does happen, I would switch over to a precedence climbing algorithm\textsuperscript{\cite{chu_2017}}. This is fairly easily implementable within participle and there is even an \href{https://github.com/alecthomas/participle/blob/master/_examples/precedenceclimbing/main.go}{example for it}.
