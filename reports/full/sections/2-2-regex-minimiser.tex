\section{Regex minimiser}

%TC:ignore
\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Thompsons: A test program to construct Thompsons construction
Might extend the program to also carry out the subset construction.
Have added the grammar for regular expressions using the participle
parser. Added a test for the Parse function to test if regex is parsed
correctly.
    \end{minted}
    \vspace{-1em}
    \tiny{October 5, 2021}
\end{center}
%TC:endignore

After writing the four-function calculator implementation I decided to translate some of the algorithms and methods used within lexical analysis described by the \textit{CS3470: Compilers And Code Generation} course. I did this mainly to supplement my learning and to understand how the algorithms worked. The implementation consists of a participle attribute grammar which accepts a language of simple regular expressions. The accepted notation includes: concatenation, alternation, grouping, and Kleene Closure and is described by the following EBNF grammar:

%TC:ignore
\begin{figure}[H]
    \begin{minted}{ebnf}
(*         Tokens        *)
(* Punct      = `[()*|]` *)
(* Char       = `[a-z]`  *)
(* whitespace = `\s*`    *)

(* Grammar *)
Base = Char | "(" Regex ")" ;
Factor = Base [ "*" ] ;
Term = { Factor } - ;
Regex = Term [ "|" Regex ] ;
    \end{minted}
    \cprotect\caption{The tokens and grammar for the regular expression parser test program unwrapped from the Go code.}
\end{figure}
%TC:endignore

The implementation minifies an input regular expression in three phases:

\begin{enumerate}
    \item Producing an NFA from the regular expression using Thompson's construction.
    \item Producing a DFA from the NFA using the subset construction.
    \item Producing a minimal DFA from the non-minimal DFA using Dead State minimisation.
\end{enumerate}

\subsection{Thompson's Construction}
\cprotect\textit{Source located in: \verb|test_programs/thompsons/thompsons.go|}

Thompson's construction is carried out in a single traversal of the produced AST. This is done by having each AST node implement the following interface:

%TC:ignore
\begin{minted}{go}
type Thompsons interface {
    Thompson(graph *Graph) (start State, end State)
}
\end{minted}
%TC:endignore

The \verb|Thompsons| instance method takes a pointer to a \verb|Graph| type, which is an adjacency list, and returns a start node and an end node. This is because when one of Thompson's constructions modifies the NFA it can introduce a new start point and end point to the NFA. For instance, in the case of alternation (\verb+"|"+) the new start and end point will be set to the created nodes that join to the existing nodes using the epsilon transition.

\begin{figure}[!h]
    \centering
    \begin{tikzpicture}
        \node[state] (u0) {$0$};
        \node[state] at (1.5, 1.5) (u1) {$1$};
        \node[state] at (4, 1.5) (u2) {$2$};
        \node[state] at (1.5, -1.5) (u3) {$3$};
        \node[state] at (4, -1.5) (u4) {$4$};
        \node[state, accepting] at (5.5, 0) (u5) {$5$};

        \draw [->] (u0) edge[above] node{$\epsilon$} (u1)
                   (u0) edge[above] node{$\epsilon$} (u3)
                   (u1) edge[above] node{$a$} (u2)
                   (u2) edge[above] node{$\epsilon$} (u5)
                   (u3) edge[below] node{$b$} (u4)
                   (u4) edge[above] node{$\epsilon$} (u5);
    \end{tikzpicture}
    \cprotect\caption{The NFA, produced by Thompson's construction, for the regular expression: \verb+a | b+. Here, the start of the graph would be at the node: $0$, and the end/accepting node would be: $5$.}
\end{figure}

%TC:ignore
\begin{figure}[H]
    \begin{minted}{go}
// Thompson construction for a Regex symbol.
func (r *Regex) Thompson(graph *Graph) (start State, end State) {
    start, end = r.Term.Thompson(graph)
    if r.Regex != nil {
        // If the Regex symbol exists then we construct the union
        // between the Term and the Regex symbol.
        start2, end2 := r.Regex.Thompson(graph)
        start, end = graph.Union(start, end, start2, end2)
    }
    return start, end
}
    \end{minted}
    \cprotect\caption{An example taken from \verb|test_programs/thompsons/thompsons.go| showing the \verb|Thompson| instance method for the \verb|Regex| AST node/non-terminal.}
\end{figure}
%TC:endignore

In the example shown above, the \verb|Term| node will be executed first. This will produce a sub-NFA that has a start, and an end point. If the \verb|Regex| field is not nil, this means that there is an alternation (\verb+"|"+) within the regular expression. This \verb|Regex| AST node/non-terminal will first be evaluated, and the alternation/union of the two will be constructed in the \verb|Graph| (using the \verb|Union| instance method). Due to \verb|Regex| being the start non-terminal of the grammar, it is possible that this method could return the finished start and end points of the fully constructed NFA.

\subsection{Subset Construction}
\cprotect\textit{Source located in: \verb|test_programs/thompsons/subset.go|}

After the NFA has been produced, the \verb|Graph| instance mentioned above is then passed to the subset construction algorithm to construct a (non-minimal) DFA. A type used extensively whilst calculating the subset construction is the \verb|StateSetExistence| type. \verb|StateSetExistence| denotes a unique set of states, and is used when calculating the possible inputs accepted by the regular expression as well as the epsilon closure.

% It is important to note that the \verb|AdjacencyList| type, that is used within the \verb|Graph| type, has the signature:

% %TC:ignore
% \begin{minted}{go}
% type AdjacencyList map[StateKey][]Edge

% // StateKey represents the key used within AdjacencyLists.
% // It wraps both State and StateSet to provide a string key usable in maps.
% type StateKey interface {
% 	// Key generates a key from a State or StateSet.
% 	Key() string
% }
% \end{minted}
% %TC:endignore

% The \verb|StateKey| interface is used within the \verb|AdjacencyList| type so that both a single state (represented as the \verb|State|), and a set of states (represented as the \verb|StateSet| type) can be easily hashed and used within Go's native \mintinline[breaklines]{go}{map} type. This is useful when carrying out the subset construction, as it merges multiple states from the NFA into a smaller number of sets of states.


%TC:ignore
\begin{minted}{go}
// StateSetExistence represents a unique set of States.
type StateSetExistence map[StateKeyString]bool

// NOTE: A StateKeyString is the stringified version 
//       of a StateKey, derived using StateKey.Key.
\end{minted}
%TC:endignore

It makes use of an interesting side effect of Go's \mintinline[breaklines]{go}{map} type. In that, when accessing a \mintinline[breaklines]{go}{map} with a key that does not exist within the \mintinline[breaklines]{go}{map}, the default value of the value type will be returned. The default value for \mintinline[breaklines]{go}{bool}s is \mintinline[breaklines]{go}{false}. This creates a succinct way of checking whether an element exists within a set.

I will not be explaining how the \verb|Subset| and \verb|EClosure| instance methods for the \verb|Graph| type work, as they are effectively just implementations of the algorithms showcased in \textit{CS3470}. Their source code can be found in the \verb|test_programs/thompsons/subset.go| file.

\subsection{Dead State Minimisation}

Dead State minimisation requires the DFA to translated into a transition table. To do this, I first created a \verb|TransitionTable| type. This type is essentially a matrix of \verb|StateKeyString| values, so I also created a constructor (\verb|InitTT|) along with it, which takes a \verb|Graph| (after having the subset construction applied to it) and returns a newly allocated \verb|TransitionTable|.

%TC:ignore
\inputminted[firstline=45, lastline=46, autogobble, breaklines, tabsize=4, ]{go}{../../test_programs/thompsons/minimisation.go}
%TC:endignore

The \verb|MergedStates| type is important to the execution of the Dead State minimisation algorithm. This is because it includes an instance method that can check if the given merged state differs from the instanced merged state, which is the main condition that must hold for Dead State minimisation to continue. Once this instance method returns \mintinline[breaklines]{go}{false}, this means that Dead State minimisation is complete and the DFA is minimal.

The source code for the algorithm itself is implemented as an instance method for the \verb|TransitionTable| type, and can be found in the \verb|test_programs/thompsons/minimisation.go| file. More information on how to run the regex minimiser can be found in the \verb|README|.
