\subsection{Expressions}
\label{sec:development-ast-nodes-expressions}

\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: Eval implementation on expression precedence levels
- Added an eval_expressions file which defines Evaluation function for each
  precedence level in the AST (03/12/2021 - 03:00:32)
- This uses some interfaces and shared functions to reduce the amount of
  duplicated code and increase readability (03/12/2021 - 03:01:12)
- Implemented JSON declaration AST node. This is done recursively using
  Eval referrers and another recursive function (03/12/2021 - 03:24:47)
- updated example 2 (03/12/2021 - 16:12:29)
- Fixed bug in Heap.Get (03/12/2021 - 16:13:24)
- Added some benchmarks for Eval and Parse to main_test (03/12/2021 - 16:13:45)
- Implemented JSONPath getter (03/12/2021 - 16:14:32)
    \end{minted}
    \vspace{-1em}
    \tiny{December 3, 2021}
\end{center}

To evaluate all AST node types that are used within the expression subtree (somewhat) easily, we use two main interfaces:

\inputminted[firstline=13, lastline=30, autogobble, breaklines, tabsize=4]{go}{../../src/parser/eval_expression.go}

This allows for each \verb|PrecNTerm| and \verb|PrecN| to be evaluated by calling an agnostic shared evaluation function for each: \verb|tEval| and \verb|fEval|. \verb|tEval| takes the \verb|term| to evaluate, pointer to a \verb|PrecNTerm| (only if \verb|PrecNTerm| has \verb|left| and \verb|right| implemented), as well as a \verb|VM| instance. First the node on the \verb|left| will be evaluated and stored within a \verb|Value| that is treated as an accumulator. Then each node on the \verb|right| will be iterated over. The current \verb|right| node's value will be evaluated. The operation described returned by the current \verb|right| node's \verb|operator| function will then be computed with the accumulator value and the evaluated \verb|right| node's value. The result of this computation will be stored back into the accumulator value. This effectively computes each \verb|term| in a left-associative manner. \verb|fTerm| is simpler, as it just needs to return the result of evaluating the \verb|inner| \verb|term| node.

\inputminted[firstline=51, lastline=92, autogobble, breaklines, tabsize=4]{go}{../../src/parser/eval_expression.go}

Examples of the implementations for \verb|PrecNTerm| and \verb|PrecN| can be found below. They can all be written comfortably on one line, as most of the implemented functions just getters for certain fields in their respective AST structs. However, the \verb|right| implementation is a lot more verbose as a \verb|factor| array has to be constructed from the nodes within the \verb|Right| field.

\begin{minted}[breaklines]{go}    
func (pt *PrecNTerm) left() evalNode { return pt.Left }
func (pt *PrecNTerm) right() []factor {f := make([]factor, len(pt.Right)); for i, v := range pt.Right {f[i] = v}; return f}

func (p *PrecN) operator() eval.Operator { return p.Operator }
func (p *PrecN) inner() term { return p.Factor }
\end{minted}

Each expression tree within the AST, will have leaf nodes that are \verb|Factor|s. Therefore, we need to treat \verb|Factor| differently from the other \verb|term| nodes. \verb|left| will return the actual value held by the \verb|Factor|, whereas \verb|right| will return an empty array of \verb|factor|s. The \verb|left| instance method for \verb|Factor| also has to deal with values that are not represented as AST nodes that implement \verb|evalNode|. Such as tokens passed from the lexer or other native types.

\inputminted[firstline=32, lastline=49, autogobble, breaklines, tabsize=4]{go}{../../src/parser/eval_expression.go}

\inputminted[firstline=130, lastline=179, autogobble, breaklines, tabsize=4]{go}{../../src/parser/eval_expression.go}

As you can see, when the \verb|Factor| is a \verb|Number| (\mintinline{go}{*float64}), or a \verb|StringLit| (\mintinline{go}{*string}) then we create an anonymous struct that uses \verb|protoEvalNode| as a template. We then set the \verb|evalMethod| to a function that returns either a \verb|Number| or a \verb|StringLit|, set \verb|stringMethod| to a function that returns the value as a string, and \verb|getPosMethod| to return an empty position (as we do not have context). \verb|protoEvalNode| implements the \verb|ASTNode| interface, which in turn means that it also implements \verb|evalNode|, and an instance of it can be returned from the \verb|left| instance method. In other words, we construct a temporary `faux' AST node for \verb|Factor|s that are numbers of string literals.

Finally, we implement the \verb|Eval| instance method for each \verb|PrecNTerm| and \verb|PrecN|, to make them implement the \verb|evalNode| interface. The source code for expression evaluation is found within its own file: \verb|src/parser/eval_expression.go|.

\inputminted[firstline=182, lastline=194, fontsize=\footnotesize, autogobble, breaklines, tabsize=4]{go}{../../src/parser/eval_expression.go}
