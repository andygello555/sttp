\subsection{HTTP Methods}

\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: Method.Call setup + tests + Resty integration
- Chose the Resty library for internal HTTP method calls (12/12/2021 - 14:21:50)
- Moved Method enum to eval package and created MethodParamType to describe the
  accepted paramters for each HTTP method call (13/12/2021 - 17:12:19)
- Added Method.Call which calls the appropriate Resty functions and encapsulates
  the returned data within a data.Value (13/12/2021 - 17:13:01)
- Added a test for Method.Call. This was done by copying the echo chamber web
  server over to the _example folder (13/12/2021 - 17:14:04)
    \end{minted}
    \vspace{-1em}
    \tiny{December 13, 2021}
\end{center}

The \verb|MethodCall| AST node has a similar syntax to function calls but instead of having a user-defined function name it can only have one of the supported \verb|sttp| HTTP methods\textsuperscript{\cite{http_request_methods}}: \verb|GET|, \verb|HEAD|, \verb|POST|, \verb|PUT|, \verb|DELETE|, \verb|OPTIONS|, and \verb|PATCH|. Before I implemented the \verb|batch| statement, \verb|MethodCall|s were always executed synchronously. The \verb|Method| token that is captured by the \verb|MethodCall| non-terminal, is itself a type (\mintinline[breaklines]{go}{type Method int}). This type has an enumeration of values each of which representing one of the supported HTTP methods (\cprotect{\hyperref[sec:development-operators]}{similar to the \verb|Operator| type}). The arguments that these \verb|Method|s take is described by the \verb|methodParams| table:

\inputminted[firstline=76, lastline=86, autogobble, breaklines, tabsize=4]{go}{../../src/eval/methods.go}

\verb|MethodParamType| has an enumeration that describes all the accepted arguments that a \verb|Method| can take. As seen in the code above, each \verb|Method| requires a \verb|Url| and can take an optional \verb|Headers| and \verb|Cookies| argument. HTTP request methods that can take a `body' in their request can also be given the \verb|Body| argument.

Internally, \verb|sttp| uses the `resty' third-party HTTP/REST client for Go\textsuperscript{\cite{resty}} to send the HTTP request itself. I chose resty because it supported most of the HTTP request methods described by the HTTP specification `out-of-the-box'. Go has a native HTTP client (\verb|net/http|), but this only comes with \verb|GET|, \verb|HEAD|, and \verb|POST| HTTP methods implemented by default. All other HTTP methods would need to be implemented via the \verb|NewRequest| function. Resty also supports automatic parsing of some of the known MIME content types into Go's native types (including \verb|application/json| into \mintinline[breaklines]{go}{map[string]interface{}}).

A \verb|Method| can be called via the \verb|Method.Call| instance method. \verb|Call| only takes an array of computed arguments without any reference to the \verb|VM|. This means that any error that occurs within \verb|Call| will need to be given context by a calling function lower down on the call stack that does have access to a \verb|VM| instance (usually \verb|MethodCall.Eval|). These given computed arguments will be applied to a \verb|resty.Request| structure which stores the request that will eventually be sent. This is done via the following code:

\inputminted[firstline=169, lastline=182, autogobble, breaklines, tabsize=4]{go}{../../src/eval/methods.go}

Here, the \verb|Method.GetParamType| is used to get the \verb|MethodParamType| for each of the arguments iteratively. \verb|Method.GetParamType| is quite interesting as it benefits from \mintinline{go}{int} being the underlying type of \verb|MethodParamType|, and uses this to cast the control variable of a for loop, iterating over the number of \verb|MethodParamType|s, into a \verb|MethodParamType|.

\inputminted[firstline=151, lastline=164, autogobble, breaklines, tabsize=4]{go}{../../src/eval/methods.go}

After the arguments have been bound the \verb|resty.Request| will be executed: \mintinline[breaklines]{go}{request.Execute(m.String(), args[0].StringLit())}. Here, \verb|m.String()| calls the \verb|Method.String| method which will return the canonical name of HTTP request method.

\subsubsection{Response Parsing}

\begin{center}
    \textbf{Git commit}
    \begin{minted}{markdown}
Language: text/html responses parsed to map[string]interface{}
- Parsed text/html responses to map[string]interface{} parse tree so that it can
  easily be traversed after adding filter queries and
  builtins (27/12/2021 - 18:18:28)
    \end{minted}
    \vspace{-1em}
    \tiny{December 27, 2021}
\end{center}

After the request has been executed, and has not produced an error. The response will be converted/parsed to an \verb|sttp| \verb|Value|. This will default to \verb|ConstructSymbol| which uses Go's native JSON parser to parse the body of the response into a type that can be used within \verb|sttp|. However, if the response's \verb|content-type| includes \verb|text/html| then Go's native HTML parser will be used to parse the response's body to a tree-like structure. This structure is then traversed to produce a \mintinline[breaklines]{go}{map[string]interface{}}, or in other words an \verb|sttp| \verb|Object|. Each node within the parsed HTML document will be converted to the following representation:

\begin{minted}[breaklines]{json}
{
    "type": "The node's type (String enumeration: text, document, element, comment, doctype, error).",
    "data": "The data stored within the tag. The tag's name, e.g. body, li, ul, etc. (String)."
    "attributes": {
        "Attribute's key (String)": "Attribute's value (Interface)"
    },
    "children": [
        {"child": "node 1"},
        {"child": "node 2"},
        {"child": "node etc."}
    ]
}
\end{minted}

HTML is parsed to an \verb|Object| so that it can be searched and filtered using the \verb|find| builtins and the JSONPath filter blocks. Allowing HTML content to be `scraped'. This HTML parsing technique was only added after the implementation of filter blocks for this very use-case. The code for \verb|Method.Call|, and other code snippets used above, can be found in the \verb|src/eval/methods.go| file.

When the interpreter encounters a \verb|MethodCall| AST node within the AST that is not inside a \verb|batch| statement. It will execute simply compute the supplied arguments to the \verb|MethodCall| and then call \verb|Method.Call| for the \verb|Method| token that was matched by the parser. Evaluation of the \verb|MethodCall| whilst within a \verb|batch| statement will be discussed in the: \cprotect{\hyperref[sec:eval-ast-nodes-batch]}{`\cprotect\textit{The \verb|batch| statement}' section}.
