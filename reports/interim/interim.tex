\documentclass[]{interim}
\usepackage[x11names, svgnames, rgb]{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{cprotect}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage[linguistics]{forest}
\usepackage{float}
\usepackage{array}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{minted}
\usepackage[style=ieee]{biblatex}
\usepackage{caption}
\usepackage{subcaption}
\usetikzlibrary{snakes,arrows,shapes}
\usepackage{fancyvrb}
\usepackage{import}
\usepackage{mdframed}

% Environments
\newenvironment{tightcenter}{%
  \setlength\topsep{0pt}
  \setlength\parskip{0pt}
  \begin{center}
}{%
  \end{center}
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2021}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 6243 words with 24 floats

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 3\textsuperscript{rd} December 2021

\vskip3em

Signature: \includegraphics[height=4em]{assets/signature.jpeg}

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Project Spec

\chapter*{Project Specification}
\addcontentsline{toc}{chapter}{Project Specification}

The \verb|sttp| (amalgamation of \textit{scripting} and \textit{HTTP}) is a dynamically typed, interpreted, scripting language written in Go using the participle parser generator by Alec Thomas\textsuperscript{\cite{thomas_2021}}. Below is the formal grammar definition of the language:

\section{Tokens}

The following are all the tokens, along with their regular expressions, that the lexical analyser accepts.

\begin{center}
    \begin{verbatim}
        # Tokens passed to the parser
        Number    = `[-+]?(\d*\.)?\d+'
        StringLit = `"(\\"|[^"])*"'
        Ident     = `[a-zA-Z_]\w*'
        Method    = `(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH)'
        Set       = `set\s'
        While     = `while\s'
        For       = `for\s'
        Do        = `\sdo\s'
        This      = `this\s'
        Break     = `break'
        Then      = `\sthen\s'
        End       = `end'
        Function  = `function\s'
        Return    = `return'
        Throw     = `throw'
        If        = `if\s'
        Elif      = `elif\s'
        Else      = `else\s'
        Catch     = `catch\s'
        Test      = `test\s'
        In        = `\sin\s'
        As        = `\sas\s'
        True      = `true'
        False     = `false'
        Null      = `null'
        Batch     = `batch\s'
        Try       = `try\s'
        Operators = `\|\||&&|<=|>=|!=|==|[-+*/%=!<>]'
        Punct     = `[;,.(){}:]|\[|\]'
        # Ignored tokens
        comment    = `//.*'
        whitespace = `\s+'
    \end{verbatim}
\end{center}

All capitalised symbols are tokens that are passed from the lexical analyser to the parser. Whereas, the uncapitalised symbols are read by the lexical analyser and ignored by the parser.

\section{Grammar}

\begin{center}
    \begin{minted}{ebnf}
        Program  = Block ;
        Block    = { [ Stmt ] ";" } [ RetStmt | ThrwStmt ] ;
        Stmt     = Ass
                 | FuncCall
                 | MethCall
                 | Break
                 | Test Exp
                 | While Exp Do Block End
                 | For Ass ";" Exp [ ";" Ass ] Do Block End
                 | For Ident [ "," Ident ] In Exp Do Block End
                 | Batch This Block End
                 | Try This Block Catch As Ident Then End
                 | Function JSONPath FuncBody
                 | If Exp Then Block { ElifSeg } [ ElseSeg ] End ;

        Ass      = Set JSONPath "=" Exp ;
        ElifSeg  = Elif Exp Then Block ;
        ElseSeg  = Else Block ;

        (* JSON Path *)
        JSONPath = Part { "." Part } ;
        Part     = Ident { "[" Exp "]" } ;

        RetStmt  = Return [ Exp ] ";" ;
        ThrwStmt = Throw [ Exp ] ";" ;
        FuncCall = JSONPath Args ;
        MethCall = Method Args ;
        FuncBody = "(" [Params] ")" Block End ;
        Params   = JSONPath { "," JSONPath } ;
        Args     = "(" [ExpList] ")" ;
        ExpList  = Exp { "," Exp } ;

        (* Our "arithmetic expressions" have 5 levels of precedence *)
        (* "||": lowest precedence *)
        Exp      = Prec5T { Prec5 } ;
        Prec5    = Prec5Op Prec5T ;
        Prec5Op  = "||" ;

        (* "&&": 2nd lowest precedence *)
        Prec5T   = Prec4T { Prec4 } ;
        Prec4    = Prec4Op Prec4T ;
        Prec4Op  = "&&" ;

        (* "==" and "!=": 3rd lowest precedence *)
        Prec4T   = Prec3T { Prec3 } ;
        Prec3    = Prec3Op Prec3T ;
        Prec3Op  = "==" | "!=" ;

        (* "<", ">", "<=", and ">=": 4th lowest precedence *)
        Prec3T   = Prec2T { Prec2 } ;
        Prec2    = Prec2Op Prec2T ;
        Prec2Op  = "<" | ">" | "<=" | ">=" ;

        (* "+" and "-": 5th lowest precedence *)
        Prec2T   = Prec1T { Prec1 } ;
        Prec1    = Prec1Op Prec1T ;
        Prec1Op  = "+" | "-" ;

        (* "*", "/", and "%": Highest precedence *)
        Prec1T   = Factor { Prec0 } ;
        Prec0    = Prec0Op Factor ;
        Prec0Op  = "*" | "/" | "%" ;

        (* The factors are our base values *)
        Factor   = Null
                 | False
                 | True
                 | Number
                 | StringLit
                 | JSONPath
                 | JSON
                 | FuncCall
                 | MethodCall
                 | "(" Exp ")" ;

        (* JSON literal *)
        JSON     = Object | Array ;
        Object   = "{" [ Members ] "}" ;
        Members  = Pair { "," Pair } ;
        Pair     = Exp ":" Exp ;
        Array    = "[" [ ExpList ] "]" ;
    \end{minted}
\end{center}

\subsection{Takeaways}

\begin{enumerate}
    \item Operator precedence is directly encoded into the grammar in 6 different precedence levels.
    \item Both boolean and arithmetic operators share the same expressions. The interpreter will automatically cast the right hand side of an expression to the correct type if possible.
    \item The grammar supports JSON literals as well as simple JSONPath\textsuperscript{\cite{goessner_2007}} accessors in both assignment and retrieval.
\end{enumerate}

\pagebreak

\section{Semantics}

\subsection{Statements}

Statements can be one of the following:

\begin{center}
    \begin{enumerate}
        \item An assignment. Only one assignment operator is supported: `='.
        \item A function call.
        \item An HTTP method call.
        \item The break keyword.
        \item Test an expression for a truthy value. Useful in testing.
        \item A `while' loop. The condition of which is an expression. This is explained more in the \hyperref[sec:expressions]{`Expressions'} subsection.
        \item A `for' loop. Supports either the ``traditional" C-style format or the iterator style format. The iterator style `for' loop has an optional additional iterator assignment for key-value pair iteration or index-value iteration.
        \item The batch statement which will execute the HTTP method calls nested within it in parallel.
        \item A function definition.
        \item An `if-elif-else' block.
        \item A `NOP'. Defined by a statement followed by a singular semi-colon.
    \end{enumerate}
\end{center}

\subsection{Variables and values}

The possible value types are strings, floats, integers, arrays, objects, `true'/`false' and `null'. This matches the types available in JSON. In fact, the type of each value will be determined by using the Golang JSON parser on the string representation of the value. Some other semantics:

\begin{center}
    \begin{itemize} 
        \item Variables can be modified using `JSON path'.
        \item Variable assignment will carry out a \textbf{deep copy}.
        \item \textbf{Variables are always passed by reference} and expressions are passed by value.
        \item \textbf{Variables are declared and defined} when a new \textbf{root identifier} is used in a JSONPath assignment that \textbf{doesn't exist} in the \textbf{current scope}.
        \item \textbf{Variables are set} when the root identifier \textbf{exists} in the \textbf{current scope}.
        \item \textbf{Variables are filled sparsely} when a \textbf{JSONPath accessing a non-existent sub-level} of the JSON is assigned to. For instance:
        \begin{verbatim}
            set hello_world = {
                "hello": "world"
            };
            set hello_world.world[1].hello = "world";
            /*
            hello = {
                "hello": "world",
                "world": [
                    null,
                    {"hello": "world"}
                ]
            }
            */
        \end{verbatim}
        \item As mentioned earlier, right hand values of operations are cast to the appropriate type if they can be. 
    \end{itemize}
\end{center}

\subsection{JSON path}

The grammar for the language supports rudimentary JSON path expressions. This includes the standard `.' property accessing or the string indexing style. Below are some valid JSON path expressions:

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
            json[0].path.is.cool
            json[0]["path"].is.["cool"]
            json[x + 2]["path"].is.["co" + "ol"]
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \cprotect\caption{Examples of some valid JSON paths. These all access the \verb|json| variable.}
\end{figure}

JSON paths can be assigned to. This sets the appropriate property of the variable.

\subsection{Expressions}
\label{sec:expressions}

Both \textbf{boolean and arithmetic expressions are a part of the same precedence hierarchy}. All operators are left-to-right associative (apart from one exception mentioned \hyperref[sec:semantics-operators-objects]{later}).

\subsubsection{Operator precedence}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| m{2cm} | m{2cm} | m{5cm} |}
            \hline
            Precedence & Operators & Description\\
            \hline
            \textbf{0} & \verb|* / %| & Multiplication, division, and modulus\\
            \hline
            \textbf{1} & \verb|+ -| & Addition and subtraction\\
            \hline
            \textbf{2} & \verb|< > <= >=| & Less than, greater than, less than or equal to, and greater than or equal to\\
            \hline
            \textbf{3} & \verb|== !=| & Equal and not equal\\
            \hline
            \textbf{4} & \verb|&&| & Logical and\\
            \hline
            \textbf{5} & \verb+||+ & Logical or\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Operators and their precedence from highest precedence (top) to lowest precedence (bottom)}
\end{figure}

\subsubsection{Conditions}

In statements that require conditions (such as `if-elif-else', `while', and `for' statements) a purely arithmetic, a purely binary operator expression, or a mixed expression can all be used. Here is a list of all truthy and falsy values.

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            Type & Truthy value & Falsy value\\
            \hline
            Boolean & \verb|true| & \verb|false|\\
            \hline
            null & & \verb|null|\\
            \hline
            Number & \verb|!= 0| & \verb|0|\\
            \hline
            String & \verb|"..."| & \verb|""|\\
            \hline
            Object & \verb|{...}| & \verb|{}|\\
            \hline
            Array & \verb|[...]| & \verb|[]|\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Table of truthy and falsy values of each type}
\end{figure}

\subsection{Operators}

Operator semantics are similar to how each operation is expected to work within formal mathematics and other programming languages. However, there are a couple of exceptions for some left-hand types.

\subsubsection{Objects}
\label{sec:semantics-operators-objects}

\begin{itemize}
    \item \textbf{Addition}: Right value will be cast to an object and merged into the left value.
    \begin{verbatim}
set left = {"left": "value"};
set right_1 = {"right_1": "value"};
set right_2 = "right_2";
set right_3 = 3;
set right_4 = ["right_4"];
set left = left + right_1 + right_2 + right_3 + right_4;

/*
left = {
    "left": "value",
    "right_1": "value",
    "right_2": null,
    "3": null,
    "1": "right_4"
}
*/
    \end{verbatim}
    \item \textbf{Subtraction}: Right value will be cast to an object and the keys from the right value will be removed from the left value.
    \item \textbf{Division}: Right associative version of subtraction.
\end{itemize}

\subsubsection{Arrays}

\begin{itemize}
    \item \textbf{Addition}: Right value will be appended to the left value.
    \item \textbf{Subtraction}: Left value will have elements that are equal to the elements in the left removed. If the element is \verb|null| then the start of the list is removed.
    \begin{verbatim}
set left = ["left"];
set right_1 = "right_1";
set right_2 = null;
set left = left + right_1 - right_2;

/*
left = ["right_1"]
*/
    \end{verbatim}
\end{itemize}

\subsection{Incompleteness}

So far the semantic specification is incomplete due to many of the specifics still changing frequently. Not mentioned in this section is:

\begin{enumerate}
    \item The specifics of the `batch' statement. Including the way that they will be evaluated. The current working theory is to do two passes of the `batch' statement, one to extract the HTTP method calls and one to execute the entire nested code within `batch' by using the values retrieved from the executed HTTP methods.
    \item The specifics of the `test' statement. What the interpreter will output to the user and interpreter flags to control what this statement does.
    \item The specifics behind type casting. This has been implemented already in the form of a lookup table of functions, but might be subject to change.
    \item The specifics behind the call stack and memory map.
\end{enumerate}

\pagebreak

\section{Example code}

\begin{verbatim}
set object = {
    "repeats": 30,
    "null": null,
    "false": false,
    "true": true,
    "pi": 3.142,
    "object": {
        "hello": "world!",
        "array": [
            1,
            1 + 1,
            1 + 1 + 1
        ]
    },
    "methodcall": GET("https://example.com"),
    "results": []
};

// Object Functions
// Self can be used to access the functions within the bound object
function object.execute(
    self.ifvar,
    self.var_ifwithin_self,
    party_variable.wow[0].a_a[0]
)
    // Parameters are JSON paths which fill sparsely fill a
    // JSON object that can be passed into the function
    for set i = 0; i < self.repeats; set i = i + 1 do
        if i % 3 == 0 then
            set self.results = self.results + GET("https://google.com");;;;
            if true then
                print(("hello" + "world")+"!");
            elif true then
                print("still true");
            else
                print("hello");print("hello 2");print("hello 3");
            end;
        elif i % 5 == 0 then
            set self.results = self.results + GET("https://twitter.com");
        elif i % 7 == 0 then
            set self.results = self.results + GET("https://reddit.com");
        else
            set self.results = self.results + GET("https://facebook.com");
        end;
    end;
    return "wow!";
end;

// Here we show three new statements:
// - Try-catch: try do ... catch as var then ... end, catches any exceptions
//   that might occur in the "try" block
// - Batch: executes the inner block twice:
//   1. A copy of the heap is made
//   2. First time is without executing any HTTP requests and instead
//      adding them to a work queue
//   3. Then all requests in the work queue are executed in parallel.
//      The results are loaded into another queue in the order they
//      were added to the work queue
//   4. The heap is restored to the copy that was made in step 1
//   5. Second time run through of the block now uses the next
//      response in the queue rather than executing the HTTP
//      request in sequence
// - For-each: iterate over the elements in an object/array/string
try this
    batch this
        for url in [
            "https://a.com",
            "https://b.com",
            "https://c.com"
        ] do
            set result = GET(url);
            print(result);
        end;
        set oops_forgot_this = GET("https://d.com");
        print(oops_forgot_this);
    end;
    throw {"error": "time", "ohno": true};
catch as err then
    print(err);
end;

set this_boy = "to be this boy";

// Same thing again but on one line (truncated for readability)
try this batch this for url in ["https://a.com","https://b.com","https://c.com"] do...

object.execute();
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}

This interim report includes the explanation and reasoning behind the test programs I have written in the first term, along with instructions on how to run and use them.

\begin{center}
    The test programs that were written and will be explained:
    \vspace{-1em}
    \begin{enumerate}
        \item A simple four-function calculator.
        \item Regex parser that generates a minimised DFA.
        \item Creating and implementing the \verb|sttp| grammar within Go using participle. This will form a part of the `end product' of the project.
        \item A simple web API designed to aid in the production of the \verb|sttp| programming language.
    \end{enumerate}
\end{center}

Along with these test programs, the interim report also includes the reports that I wrote during the first term.

Also included is the progress that has been made towards implementing the final product and the journey of the \verb|sttp| programming language thus far. This includes any important engineering decisions that were made as well as any research or theory which influenced said decision.

\chapter{Test programs}

\import{./}{interim-chap2.tex}

\chapter{Report - Context-free grammars and manual procedures for parsing languages}

\import{./}{interim-chap3.tex}

\chapter{Report - The use derivation rules, and grammar idioms to capture notions of associativity and precedence in arithmetic expressions}

\import{./}{interim-chap4.tex}

\chapter{Development of sttp}

\vspace{-2em}

\textit{Text in italics are project diary entries.}

\section{Mid-October}

\begin{center}
    \textit{``This week I focussed on writing up the grammar for my interpreted programming language. I ended starting the write-up of a grammar and semantics specification as well as the grammar implementation within the participle parser generator. The specification can be found in the reports directory and the go implementation can be found in the src directory. Even though this counts as one of my test programs it will become a part of my finished product, hence why it is located in src."}\\[0.5em]
    \tiny{3:33 pm on October 24, 2021}
\end{center}

Development of \verb|sttp| began in mid-October. I started by writing a formal definition of the grammar. Much of the grammar was inspired directly by Lua's grammar\textsuperscript{\cite{ierusalimschy_henrique-de-figueiredo_celes_2020}}. I chose to encode operator precedence within the grammar and keep every operator left-associative within the grammar. I then implemented this grammar within Go using participle by defining the AST node \verb|struct| types. I then also added a way of printing back out the AST as \verb|sttp| source code in order to test if programs were being parsed correctly.

\section{End of October}

\begin{center}
    \textit{``...I then added a parallelism construct and a try-catch statement to the grammar of [the] language as well as adding some more information about these to the spec..."}\\[0.5em]
    \tiny{8:21 am on October 31, 2021}
\end{center}

The original grammar did not contain a construct for exception handling so I added this to both the specification and the Go source code.

Also added around this period of time was the `batch' statement. This will allow for parallel execution of HTTP methods nested within it. This is made possible using Go's extensive parallelism support. The initial algorithm for said statement is described below using the following example code snippet:

\begin{center}
    \begin{verbatim}
01 batch this
02     for url in [
03         "https://a.com",
04         "https://b.com",
05         "https://c.com"
06     ] do
07         set result = GET(url);
08         print(result);
09     end;
10     set oops_forgot_this = GET("https://d.com");
11     print(oops_forgot_this);
12 end;
    \end{verbatim}
\end{center}

A \verb|batch| block is \textbf{always evaluated twice}. This means that it is important to \textbf{keep all non-HTTP-method-call statements and expressions to a minimum} as these will only slow down the interpreter.

Before the first pass begins, the contents of the variables in memory are deep copied so that they can be reverted to after the first pass. In the first pass, the interpreter enqueues every single HTTP method call as a job within a work queue. Each job has a unique ID and the order of this work queue is saved (more on this later). In the example, the HTTP method on line 7 will be added to the work queue 3 separate times with different arguments. Whereas, the HTTP method on line 10 is only enqueued once.

After this, the jobs in the work queue are executed using a pool of threads. The result of each job is added to a queue along with the executed job's ID. The result queue is then sorted back into the same order in which their respective jobs were added to the work queue. For instance, the result queue of the example above might look like this:

\begin{center}
    \begin{verbatim}
                Head -> "Response from 'a'" ->
                        "Response from 'b'" ->
                        "Response from 'c'" ->
                        "Response from 'd'"
    \end{verbatim}
\end{center}

Then, the contents of the variables in memory are set back to what they were before the first pass and the second pass is initiated. In the second pass, each time an HTTP method call is stepped into the next result in the result queue is dequeued and used.

\subsection{Caveats}

\begin{enumerate}
    \item You cannot use a batch statement within a batch statement.
    \item Method calls within functions are not batched.
    \item Try-catch surrounding batch statements. An exception thrown within the batch statement will cancel the two-pass algorithm.
\end{enumerate}

\subsection{Performance clarification}

From experience I believe that the performance benefits from the batch statement will outweigh the overhead of the two passes required to execute them. My reasoning behind thinking this comes from my experience of using HTTP request libraries in CPython. CPython threading, which is managed by the CPython interpreter and not the OS, give significant performance boosts to the \href{https://docs.python-requests.org/en/latest/}{requests} library (from experience). This is because, despite having a GIL (global interpreter lock), the GIL is released when I/O operations are happening, such as when making an HTTP request. Given this knowledge, I believe that the two passes done within the batch statement will be outweighed by the performance boosts of making requests in parallel. However, this will be tested later on and if this doesn't prove to have performance benefits, then this method of batch execution will be rethought.

To make the HTTP requests in parallel, I will be using goroutines. Goroutines are only allocated stack space and are multiplexed onto multiple OS threads, which makes them lightweight and non-blocking when it comes to I/O operations\textsuperscript{\cite{effective-go}}. It is also easy to communicate between them by using channels.

\section{November}

\begin{center}
    \textit{``This week I worked more on the programming language I am creating. In particular, I added a lookup table of cast functions which contains the functions needed for casting each type to another type. Of course, you arenâ€™t able to cast any type to any type. Then I moved onto the operator computation lookup table."}\\[0.5em]
    \tiny{6:44 pm on November 14, 2021}
\end{center}

Starting November, I added some basic data structures such as a variable memory heap, a call stack and a VM object which will be parsed to each evaluation function for each AST node. After this, I started work on a casting lookup table as well as an operator action lookup table.

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}
% \nocite{*}
\printbibliography

\end{document}

\end{article}
