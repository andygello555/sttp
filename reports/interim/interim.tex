\documentclass[]{interim}
\usepackage[x11names, svgnames, rgb]{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{cprotect}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage[linguistics]{forest}
\usepackage{float}
\usepackage{array}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{minted}
\usepackage[style=ieee]{biblatex}
\usepackage{caption}
\usepackage{subcaption}
\usetikzlibrary{snakes,arrows,shapes}
\usepackage{fancyvrb}
\usepackage{import}
\usepackage{mdframed}

% Environments
\newenvironment{tightcenter}{%
  \setlength\topsep{0pt}
  \setlength\parskip{0pt}
  \begin{center}
}{%
  \end{center}
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsubsection]
\addbibresource{ref.bib}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Jakab Zeller}
\def\reportyear{2021}
\def\projecttitle{Computer Language Design and Engineering}
\def\supervisorname{Adrian Johnstone}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 

\vskip3em

Signature:

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}

Although there exists many tools for testing and developing web-based APIs, there are not many solutions which provide full user freedom when it comes to control-flow. This project proposes a solution in the form of a dynamically typed, interpreted, scripting language with features enabling the use of web-based APIs `out-of-the-box', as well as other helpful tooling.

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Project Spec

\chapter*{Project Specification}
\addcontentsline{toc}{chapter}{Project Specification}

The \verb|sttp| (amalgamation of \textit{scripting} and \textit{HTTP}) is a dynamically typed, interpreted, scripting language written in Go using the participle parser generator by Alec Thomas\textsuperscript{\cite{thomas_2021}}. Below is the formal grammar definition of the language:

\section{Tokens}

The following are all the tokens, along with their regular expressions, that the lexical analyser accepts.

\begin{center}
    \begin{verbatim}
        # Tokens passed to the parser
        Number    = `[-+]?(\d*\.)?\d+'
        StringLit = `"(\\"|[^"])*"'
        Ident     = `[a-zA-Z_]\w*'
        Method    = `(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH)'
        Set       = `set\s'
        While     = `while\s'
        For       = `for\s'
        Do        = `\sdo\s'
        This      = `this\s'
        Break     = `break'
        Then      = `\sthen\s'
        End       = `end'
        Function  = `function\s'
        Return    = `return'
        Throw     = `throw'
        If        = `if\s'
        Elif      = `elif\s'
        Else      = `else\s'
        Catch     = `catch\s'
        Test      = `test\s'
        In        = `\sin\s'
        As        = `\sas\s'
        True      = `true'
        False     = `false'
        Null      = `null'
        Batch     = `batch\s'
        Try       = `try\s'
        Operators = `\|\||&&|<=|>=|!=|==|[-+*/%=!<>]'
        Punct     = `[;,.(){}:]|\[|\]'
        # Ignored tokens
        comment    = `//.*'
        whitespace = `\s+'
    \end{verbatim}
\end{center}

All capitalised symbols are tokens that are passed from the lexical analyser to the parser. Whereas, the uncapitalised symbols are read by the lexical analyser and ignored by the parser.

\section{Grammar}

\begin{center}
    \begin{verbatim}
        Program  ::= Block
        Block    ::= { [ Stmt ] ";" } [ RetStmt | ThrwStmt ]
        Stmt ::= Ass |
                 FuncCall |
                 MethCall |
                 Break |
                 Test Exp |
                 While Exp Do Block End |
                 For Ass ";" Exp [ ";" Ass ] Do Block End |
                 For Ident [ "," Ident ] In Exp Do Block End |
                 Batch This Block End |
                 Try This Block Catch As Ident Then End |
                 Function JSONPath FuncBody |
                 If Exp Then Block { ElifSeg } [ ElseSeg ] End

        Ass      ::= Set JSONPath "=" Exp
        ElifSeg  ::= Elif Exp Then Block
        ElseSeg  ::= Else Block

        # JSON Path
        JSONPath ::= Part { "." Part }
        Part     ::= Ident { "[" Exp "]" }

        RetStmt  ::= Return [ Exp ] ";"
        ThrwStmt ::= Throw [ Exp ] ";"
        FuncCall ::= JSONPath Args
        MethCall ::= Method Args
        FuncBody ::= "(" [Params] ")" Block End
        Params   ::= JSONPath { "," JSONPath }
        Args     ::= "(" [ExpList] ")"
        ExpList  ::= Exp { "," Exp }

        # Our "arithmetic expressions" have 5 levels of precedence
        # "||": lowest precedence
        Exp      ::= Prec5T { Prec5 }
        Prec5    ::= Prec5Op Prec5T
        Prec5Op  ::= "||"

        # "&&": 2nd lowest precedence
        Prec5T   ::= Prec4T { Prec4 }
        Prec4    ::= Prec4Op Prec4T
        Prec4Op  ::= "&&"

        # "==" and "!=": 3rd lowest precedence
        Prec4T   ::= Prec3T { Prec3 }
        Prec3    ::= Prec3Op Prec3T
        Prec3Op  ::= "==" | "!="

        # "<", ">", "<=", and ">=": 4th lowest precedence
        Prec3T   ::= Prec2T { Prec2 }
        Prec2    ::= Prec2Op Prec2T
        Prec2Op  ::= "<" | ">" | "<=" | ">="

        # "+" and "-": 5th lowest precedence
        Prec2T   ::= Prec1T { Prec1 }
        Prec1    ::= Prec1Op Prec1T
        Prec1Op  ::= "+" | "-"

        # "*", "/", and "%": Highest precedence
        Prec1T   ::= Factor { Prec0 }
        Prec0    ::= Prec0Op Factor
        Prec0Op  ::= "*" | "/" | "%"

        # The factors are our base values
        Factor   ::= Null |
                     False |
                     True |
                     Number |
                     StringLit |
                     JSONPath |
                     JSON |
                     FuncCall |
                     MethodCall |
                     "(" Exp ")"

        # JSON literal
        JSON     ::= Object | Array
        Object   ::= "{" [ Members ] "}"
        Members  ::= Pair { "," Pair }
        Pair     ::= Exp ":" Exp
        Array    ::= "[" [ ExpList ] "]"
    \end{verbatim}
\end{center}

\subsection{Takeaways}

\begin{enumerate}
    \item Operator precedence is directly encoded into the grammar in 6 different precedence levels using precedence climbing.
    \item Both boolean and arithmetic operators share the same expressions. The interpreter will automatically cast the right hand side of an expression to the correct type if possible.
    \item The grammar supports JSON literals as well as simple JSONPath\textsuperscript{\cite{goessner_2007}} accessors in both assignment and retrieval.
\end{enumerate}

\pagebreak

\section{Semantics}

\subsection{Statements}

Statements can be one of the following:

\begin{center}
    \begin{enumerate}
        \item An assignment. Only one assignment operator is supported: `='.
        \item A function call.
        \item A HTTP method call.
        \item The break keyword.
        \item Test an expression for a truthy value. Useful in testing.
        \item A `while' loop. The condition of which is an expression. This is explained more in the \hyperref[sec:expressions]{`Expressions'} subsection.
        \item A `for' loop. Supports either the ``traditional" C-style format or the iterator style format. The iterator style `for' loop has an optional additional iterator assignment for key-value pair iteration or index-value iteration.
        \item The batch statement which will execute HTTP method calls nested within it in parallel.
        \item A function definition.
        \item An `if-elif-else' block.
        \item A `NOP'. Defined by a statement followed by a singular semi-colon.
    \end{enumerate}
\end{center}

\subsection{Variables and values}

The possible value types are strings, floats, integers, arrays, objects, `true'/`false' and `null'. This matches the types available in JSON. In fact the type of each value will be determined by using the Golang JSON parser on the string representation of the value. Some other semantics:

\begin{center}
    \begin{itemize} 
        \item Variables can be modified using `JSON path'.
        \item Variable assignment will carry out a \textbf{deep copy}.
        \item \textbf{Variables are always passed by reference} and expressions are passed by value.
        \item \textbf{Variables are declared and defined} when a new \textbf{root identifier} is used in a JSONPath assignment that \textbf{doesn't exist} in the \textbf{current scope}.
        \item \textbf{Variables are set} when the root identifier \textbf{exists} in the \textbf{current scope}.
        \item \textbf{Variables are filled sparsely} when a \textbf{JSONPath accessing a non-existent sublevel} of the JSON is assigned to. For instance:
        \begin{verbatim}
            set hello_world = {
                "hello": "world"
            };
            set hello_world.world[1].hello = "world";
            /*
            hello = {
                "hello": "world",
                "world": [
                    null,
                    {"hello": "world"}
                ]
            }
            */
        \end{verbatim}
        \item As mentioned earlier, right hand values of operations are cast to the appropriate type if they can be. 
    \end{itemize}
\end{center}

\subsection{JSON path}

The grammar for the language supports rudimentary JSON path expressions. This includes the standard `.' property accessing or the string indexing style. Below are some valid JSON path expressions:

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
            json[0].path.is.cool
            json[0]["path"].is.["cool"]
            json[x + 2]["path"].is.["co" + "ol"]
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \cprotect\caption{Examples of some valid JSON paths. These all access the \verb|json| variable.}
\end{figure}

JSON paths can be assigned to. This sets the appropriate property of the variable.

\pagebreak

\subsection{Expressions}
\label{sec:expressions}

Both \textbf{boolean and arithmetic expressions are a part of the same precedence hierarchy}. \textbf{All operators are left-to-right associative}.

\subsubsection{Operator precedence}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| m{2cm} | m{2cm} | m{5cm} |}
            \hline
            Precedence & Operators & Description\\
            \hline
            \textbf{0} & \verb|* / %| & Multiplication, division, and modulus\\
            \hline
            \textbf{1} & \verb|+ -| & Addition and subtraction\\
            \hline
            \textbf{2} & \verb|< > <= >=| & Less than, greater than, less than or equal to, and greater than or equal to\\
            \hline
            \textbf{3} & \verb|== !=| & Equal and not equal\\
            \hline
            \textbf{4} & \verb|&&| & Logical and\\
            \hline
            \textbf{5} & \verb+||+ & Logical or\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Operators and their precedence from highest precedence (top) to lowest precedence (bottom)}
\end{figure}

\subsubsection{Conditions}

In statements that require conditions (such as `if-elif-else', `while', and `for' statements) a purely arithmetic, a purely binary operator expression, or a mixed expression can all be used. Here is a list of all truthy and falsy values.

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            Type & Truthy value & Falsy value\\
            \hline
            Boolean & \verb|true| & \verb|false|\\
            \hline
            null & & \verb|null|\\
            \hline
            Number & \verb|!= 0| & \verb|0|\\
            \hline
            String & \verb|"..."| & \verb|""|\\
            \hline
            Object & \verb|{...}| & \verb|{}|\\
            \hline
            Array & \verb|[...]| & \verb|[]|\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Table of truthy and falsy values of each type}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}

This interim report includes the explanation and reasoning behind the test programs I have written in the first term, along with instructions on how to run and use them.

\begin{center}
    The test programs that were written and will be explained:
    \vspace{-1em}
    \begin{enumerate}
        \item A simple four function calculator
        \item Regex parser that generates a minimised DFA
        \item A simple web-API designed to aid in the production of the \verb|sttp| programming language
    \end{enumerate}
\end{center}

Along with these test programs, the interim report also includes the reports that I wrote during the first term.

Also included is the progress that has been made towards implementing the final product and the journey of the \verb|sttp| programming language thus far. This includes any important engineering decisions that were made as well as any research or theory which influenced said decision.

\chapter{Test programs}

\import{./}{interim-chap2.tex}

\chapter{Report - Context-free grammars and manual procedures for parsing languages}

\import{./}{interim-chap3.tex}

\chapter{Report - The use derivation rules, and grammar idioms to capture notions of associativity and precedence in arithmetic expressions}

\import{./}{interim-chap4.tex}

\chapter{Development of sttp}

\section{Mid-October}

Development of \verb|sttp| begun in mid-October. I started by writing a formal definition of the grammar. Much of the grammar was inspired directly by Lua's grammar\textsuperscript{\cite{ierusalimschy_henrique-de-figueiredo_celes_2020}}. I chose to encode operator precedence within the grammar and keep every operator left associative within the grammar (due to participle generating a recursive descent parser). I then implemented this grammar within Go using participle by defining the AST node \verb|struct| types. I then also added a way of printing back out the AST as \verb|sttp| source code in order to test if programs were being parsed correctly.

\section{}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\label{endpage}
% \nocite{*}
\printbibliography

\end{document}

\end{article}
