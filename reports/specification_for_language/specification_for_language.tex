\documentclass[12pt, letterpaper]{article}

\usepackage{float}
\usepackage{cprotect}
\usepackage{array}
\usepackage{hyperref}
\usepackage{minted}

% Metadata
\title{Specification for Web API testing language}

\author{Jakab Zeller}

\date{October 2021}

\begin{document}

\maketitle

\section{Tokens}

The following are all the tokens, along with their regular expressions, that the lexical analyser accepts.

\begin{center}
    \begin{verbatim}
        # Tokens passed to the parser
        Number    = `[-+]?(\d*\.)?\d+'
        StringLit = `"(\\"|[^"])*"'
        Ident     = `[a-zA-Z_]\w*'
        Method    = `(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH)'
        While     = `while\s'
        For       = `for\s'
        Do        = `\sdo\s'
        This      = `this\s'
        Break     = `break'
        Then      = `\sthen\s'
        End       = `end'
        Function  = `function\s'
        Return    = `return'
        Throw     = `throw'
        If        = `if\s'
        Elif      = `elif\s'
        Else      = `else\s'
        Catch     = `catch\s'
        Test      = `test\s'
        In        = `\sin\s'
        As        = `\sas\s'
        True      = `true'
        False     = `false'
        Null      = `null'
        Batch     = `batch\s'
        Try       = `try\s'
        Operators = `\|\||&&|<=|>=|!=|==|[-+*/%=!<>]'
        Punct     = `[$;,.(){}:]|\[|\]'
        # Ignored tokens
        comment    = `//.*'
        whitespace = `\s+'
    \end{verbatim}
\end{center}

All capitalised symbols are tokens that are passed from the lexical analyser to the parser. Whereas, the uncapitalised symbols are read by the lexical analyser and ignored by the parser.

\section{Grammar}

\begin{center}
    \begin{minted}{ebnf}
        Program  = Block ;
        Block    = { [ Stmt ] ";" } [ RetStmt | ThrwStmt ] ;
        Stmt     = Ass
                 | FuncCall
                 | MethCall
                 | Break
                 | Test Exp
                 | While Exp Do Block End
                 | For Ass ";" Exp [ ";" Ass ] Do Block End
                 | For Ident [ "," Ident ] In Exp Do Block End
                 | Batch This Block End
                 | Try This Block Catch As Ident Then End
                 | Function JSONPath FuncBody
                 | If Exp Then Block { ElifSeg } [ ElseSeg ] End ;

        Ass      = JSONPath "=" Exp ;
        ElifSeg  = Elif Exp Then Block ;
        ElseSeg  = Else Block ;

        (* JSON Path *)
        JSONPath = Part { "." Part } ;
        Part     = Ident { "[" Exp "]" } ;

        RetStmt  = Return [ Exp ] ";" ;
        ThrwStmt = Throw [ Exp ] ";" ;
        FuncCall = "$" JSONPath Args ;
        MethCall = "$" Method Args ;
        FuncBody = "(" [Params] ")" Block End ;
        Params   = JSONPath { "," JSONPath } ;
        Args     = "(" [ExpList] ")" ;
        ExpList  = Exp { "," Exp } ;

        (* Our "arithmetic expressions" have 5 levels of precedence *)
        (* "||": lowest precedence *)
        Exp      = Prec5T { Prec5 } ;
        Prec5    = Prec5Op Prec5T ;
        Prec5Op  = "||" ;

        (* "&&": 2nd lowest precedence *)
        Prec5T   = Prec4T { Prec4 } ;
        Prec4    = Prec4Op Prec4T ;
        Prec4Op  = "&&" ;

        (* "==" and "!=": 3rd lowest precedence *)
        Prec4T   = Prec3T { Prec3 } ;
        Prec3    = Prec3Op Prec3T ;
        Prec3Op  = "==" | "!=" ;

        (* "<", ">", "<=", and ">=": 4th lowest precedence *)
        Prec3T   = Prec2T { Prec2 } ;
        Prec2    = Prec2Op Prec2T ;
        Prec2Op  = "<" | ">" | "<=" | ">=" ;

        (* "+" and "-": 5th lowest precedence *)
        Prec2T   = Prec1T { Prec1 } ;
        Prec1    = Prec1Op Prec1T ;
        Prec1Op  = "+" | "-" ;

        (* "*", "/", and "%": Highest precedence *)
        Prec1T   = Factor { Prec0 } ;
        Prec0    = Prec0Op Factor ;
        Prec0Op  = "*" | "/" | "%" ;

        (* The factors are our base values *)
        Factor   = Null
                 | False
                 | True
                 | Number
                 | StringLit
                 | JSONPath
                 | JSON
                 | FuncCall
                 | MethodCall
                 | "(" Exp ")" ;

        (* JSON literal *)
        JSON     = Object | Array ;
        Object   = "{" [ Members ] "}" ;
        Members  = Pair { "," Pair } ;
        Pair     = Exp ":" Exp ;
        Array    = "[" [ ExpList ] "]" ;
    \end{minted}
\end{center}

\subsection{Takeaways}

\begin{enumerate}
    \item Operator precedence is directly encoded into the grammar in 6 different precedence levels.
    \item Both boolean and arithmetic operators share the same expressions. The interpreter will automatically cast the right hand side of an expression to the correct type if possible.
    \item The grammar supports JSON literals as well as simple JSONPath accessors in both assignment and retrieval.
\end{enumerate}

\section{Semantics}

\subsection{Statements}

Statements can be one of the following:

\begin{center}
    \begin{enumerate}
        \item An assignment. Only one assignment operator is supported: `='.
        \item A function call.
        \item A HTTP method call.
        \item The break keyword.
        \item Test an expression for a truthy value. This will be talked about more in the `Test Suite' section.
        \item A `while' loop. The condition of which is an expression. This is explained more in the \hyperref[sec:expressions]{`Expressions'} subsection.
        \item A `for' loop. Supports either the ``traditional" C-style format or the iterator style format. The iterator style `for' loop has an optional additional iterator assignment for key-value pair iteration or index-value iteration.
        \item The batch statement which will execute HTTP method calls nested within it in parallel.
        \item A function definition.
        \item An `if-elif-else' block.
        \item A `NOP'. Defined by a statement followed by a singular semi-colon.
    \end{enumerate}
\end{center}

\subsection{Variables and values}

The possible value types are strings, floats, integers, arrays, objects, `true'/`false' and `null'. This matches the types available in JSON. In fact the type of each value will be determined by using the Golang JSON parser on the string representation of the value. Some other semantics:

\begin{center}
    \begin{itemize}
        \item Variables can be modified using `JSON path'.
        \item Variable assignment will carry out a \textbf{deep copy}.
        \item \textbf{Variables are always passed by reference} and expressions are passed by value.
        \item \textbf{Variables are declared and defined} when a new \textbf{root identifier} is used in a JSONPath assignment that \textbf{doesn't exist} in the \textbf{current scope}.
        \item \textbf{Variables are set} when the root identifier \textbf{exists} in the \textbf{current scope}.
        \item \textbf{Variables are filled sparsely} when a \textbf{JSONPath accessing a non-existent sublevel} of the JSON is assigned to. For instance:
        \begin{verbatim}
            hello_world = {
                "hello": "world"
            };
            hello_world.world[1].hello = "world";
            /*
            hello_world = {
                "hello": "world",
                "world": [
                    null,
                    {"hello": "world"}
                ]
            }
            */
        \end{verbatim}
        \item As mentioned earlier, right hand values of operations are cast to the appropriate type if they can be. 
    \end{itemize}
\end{center}

\subsection{JSON path}

The grammar for the language supports rudimentary JSON path expressions. This includes the standard `.' property accessing or the string indexing style. Below are some valid JSON path expressions:

\begin{figure}[H]
    \begin{center}
        \begin{verbatim}
            json[0].path.is.cool
            json[0]["path"].is.["cool"]
            json[x + 2]["path"].is.["co" + "ol"]
        \end{verbatim}
    \end{center}
    \vspace{-1.5em}
    \cprotect\caption{Examples of some valid JSON paths. These all access the \verb|json| variable.}
\end{figure}

When accessing a variable using JSONPath, the variable that is being accessed is called the \textbf{root identifier/property}. This is the first identifier in the JSONPath.

\begin{verbatim}
    // Here the variable that is being accessed
    // is the "json" variable.
    json.hello.world
\end{verbatim}

A JSONPath is constructed from \textbf{properties} and \textbf{parts}. A property is an identifier which directly correlates to a key within an object. A part is an expression surrounded by square braces.

Each part's expression is first evaluated. If the result of this expression is a value of type String then the part will be treated as a property. If the value of the result is of type Number, then the value will be treated as an access to an array. If the value is not of type String or Number, then the interpreter will first try to cast the value to a Number, and then to a String. If the value cannot be cast to either, an error is returned.

\subsubsection{Getting}
\label{sec:jsonpath-getting}

A JSONPath that is used to `get' a value, will not produce an error if the JSONPath doesn't point to a value. Instead the JSONPath will return a `null' value.

Parts that evaluate to Numbers can also be negative if \verb|abs(i) - 1| is less than the length of the Array to access. Negative numbers allow access from the tail of the Array. For instance:

\begin{verbatim}
    a = [1, 2, 3];
    $print(a[-1], a[-2], a[-3]);
    // Output: 3 2 1
\end{verbatim}

\subsubsection{Setting}

JSON paths can be assigned to. This sets the appropriate property of the variable. This is done recursively by reconstructing the entire value from the bottom-up. Each recursive call takes the current value, the value to set to, as well as the path remaining to evaluate (an array of properties and parts).

\begin{center}
    For each property/part in the JSONPath, the following considerations are made.
    \begin{itemize}
        \item If we have no path remaining, then we will return the value we are setting to.
        \item If the current value is `null' then we won't pop the next property/path from the JSONPath. Instead, we will create a new Object, if the current path evaluates to a String, or a new Array, if the current path evaluates to a Number.
        \item For each of the following actions we will first pop the next item from the remaining path...
        \begin{itemize}
            \item If the current value is an \textbf{Object}...
            \begin{itemize}
                \item \textbf{If the current path item is a String}, then we will treat it as a key of the Object. We will set the value of the key in the current Object to be the output of a recursive call of the setter function. The current value to pass into the recursive call depends on whether the key already exists in the Object. If it does then we will pass in the value of the key. If it doesn't then we will pass in `null'.
                \item \textbf{If the current path item is a Number}, then we will order the keys within the Object lexicographically and set the \verb|i|-th key's value using the technique described above. Where \verb|i| is the current path item.
            \end{itemize}
            \item If the current value is an \textbf{Array} and the current path item is a Number.
            \begin{itemize}
                \item Check if a negative index lookup can be performed as described in the `\hyperref[sec:jsonpath-getting]{Getting}' section...
                \begin{itemize}
                    \item If so, then we will set the index of the Array to be the output of the recursive call to the setter function called with the element currently at that index.
                    \item If not, then we will set each element of the Array up to the index described by the Number to `null' and finally recurse down the index to set, calling the recursive function with `null'.
                \end{itemize}
            \end{itemize}
            \item If the current value has \textbf{any other type}...
            \begin{itemize}
                \item \textbf{If the current path item is a String}, then we will wrap the current value into an Object with the value residing in a key-value pair of the key \verb|""|. We will then recurse down the key with the value of the current path item, calling the recursive function with `null'. \verb|""| was chosen as the `default key', because it will always be sorted lexicographically as the first key. This means that the value which used to reside there can be accessed by a part such as \verb|[""]| or \verb|[0]|.
                \item \textbf{If the current path item is a Number}, then we will wrap the current value into an Array. If we let the current path value be denoted by \verb|i|, then first we will create an Array with \verb|i + 2| spaces. Inserting the existing value in space \verb|i + 1| and recursing down the \verb|i|-th space, calling the recursive function with `null'.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{center}

If the value being set is a Function type then we'll construct a new FunctionDefinition AST node, that will float outside the AST. This node will contain the body and parameters of the Function value that is being set, but will point to the JSONPath AST node of the variable that it is being assigned to.

\subsection{Expressions}
\label{sec:expressions}

Both \textbf{boolean and arithmetic expressions are a part of the same precedence hierarchy}. \textbf{All operators are left-to-right associative}.

\subsubsection{Operator precedence}

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| m{2cm} | m{2cm} | m{5cm} |}
            \hline
            Precedence & Operators & Description\\
            \hline
            \textbf{0} & \verb|* / %| & Multiplication, division, and modulus\\
            \hline
            \textbf{1} & \verb|+ -| & Addition and subtraction\\
            \hline
            \textbf{2} & \verb|< > <= >=| & Less than, greater than, less than or equal to, and greater than or equal to\\
            \hline
            \textbf{3} & \verb|== !=| & Equal and not equal\\
            \hline
            \textbf{4} & \verb|&&| & Logical and\\
            \hline
            \textbf{5} & \verb+||+ & Logical or\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Operators and their precedence from highest precedence (top) to lowest precedence (bottom)}
\end{figure}

Expressions, and subsequently operators, are evaluated from left to right. Most operator actions involve casting the right-hand side into the type of the value on the left-hand side, then finally performing the operation. This can be used to the benefit of the programmer for various needs, such as casting a value to another type.

\begin{verbatim}
    // Here the Array will be cast to a Number, which will 
    // result in the Array's length
    length = 0 + [1, 2, 3];
\end{verbatim}

\subsubsection{Conditions}

In statements that require conditions (such as `if-elif-else', `while', and `for' statements) a purely arithmetic, a purely logical operator expression, or a mixed expression can all be used. If the expression does not result in a value of a Boolean type, then the result will be cast into a Boolean using the truthy and falsy values below.

\begin{figure}[H]
    \begin{center}
        \begin{tabular}{| c | c | c |}
            \hline
            Type & Truthy value & Falsy value\\
            \hline
            Boolean & \verb|true| & \verb|false|\\
            \hline
            null & & \verb|null|\\
            \hline
            Number & \verb|!= 0| & \verb|0|\\
            \hline
            String & \verb|"..."| & \verb|""|\\
            \hline
            Object & \verb|{...}| & \verb|{}|\\
            \hline
            Array & \verb|[...]| & \verb|[]|\\
            \hline
        \end{tabular}
    \end{center}
    \caption{Table of truthy and falsy values of each type}
\end{figure}

\subsection{Operator-value relationship}
\label{sec:operatorvaluerel}

Instead of having built-in functions for operations such as appending to an array, removing from an array, merging objects, etc. Operators, perform most of these actions. The following operators remain unchanged for all types:

\begin{itemize}
    \item \textbf{Equal}: \textbf{Deep} equal. \textbf{Returns boolean}.
    \item \textbf{Not-equal}: \textbf{Deep} not-equal. \textbf{Returns boolean}.
    \item \textbf{Less-than, greater-than, less-than or equal, greater-than or equal}: First checks if the first operand is of type Number or String (comparable types). If not then the first operand will be tried to be cast into a Number, and then a String, and if it still cannot, an error will be returned. Then the second operand is cast into the type of the newly cast first operand, returning an error if required. Then these newly cast operands are compared and a Boolean value is returned. \textbf{Null cannot be compared}.
    \item \textbf{Logical And}: Compares by casting both operands to boolean values.
    \item \textbf{Logical Or}: Compares by casting both operands to boolean values.
\end{itemize}

Below, is a run through of each supported operation for each type. \textit{Note that this presumes that all of the types below are on the left-hand side of the operator.}

\subsubsection{Objects}

\begin{itemize}
    \item \textbf{Addition}: Will merge the RHS into the left overriding any values with the same key.
    \item \textbf{Subtraction}: Left value will have key-value pairs found in right value deleted from it.
    \item \textbf{Divide}: Right associative set difference. $op2 - op1$ or $op2 \setminus op1$. This will still have to cast the RHS to an Object.
\end{itemize}

\subsubsection{Arrays}

\begin{itemize}
    \item \textbf{Addition}: Right value will be appended to the left value. Note that the RHS is \textbf{not cast} to the Array type.
    \item \textbf{Subtraction}: Subtract elements from Array. All elements on the LHS Equal to the elements in the RHS will be removed. If the element is null then the head of the Array is removed. The same element cannot be removed more than once in the same operation. This includes `null'.
\end{itemize}

\subsubsection{Strings}

\begin{itemize}
    \item \textbf{Multiply}: Will repeat the String on the left $n$ times, where $n$ is the RHS cast to a Number.
    \item \textbf{Modulus}: Casts RHS to Array then performs a string format using the verbs available in Go.
    \item \textbf{Addition}: Concatenation.
    \item \textbf{Subtraction}: Depending on the type of the RHS the following will happen:
    \begin{itemize}
        \item \textbf{Number}:  Remove the last n digits from the String.
        \item \textbf{String}:  Remove all occurrences of the RHS from the LHS.
        \item \textbf{Object}:  Replaces all occurrences of RHS's keys with String versions of their values.
        \item \textbf{Array}:   Casts each element in the array to a string and removes all occurrences of each from the LHS.
        \item \textbf{Default}: Casts RHS to string and removes all occurrences of it from the LHS.
    \end{itemize}
\end{itemize}

\subsubsection{Numbers}

All operators work as expected.

\subsubsection{Booleans}

\begin{itemize}
    \item \textbf{Multiply}: Same as Logical And.
    \item \textbf{Divide}: Inverse of Logical And (NAND).
    \item \textbf{Modulus}: The material conditional/Implies that. $op1 \rightarrow op2$.
    \item \textbf{Addition}: Same as Logical Or.
    \item \textbf{Subtraction}: Inverse of Logical Or (NOR).
\end{itemize}

\subsubsection{Nulls}

Multiply, Divide, Modulus, Addition, and Subtraction will all `nullify' the operation (result in `null'). Null cannot be compared but can be used in logical expressions where it will be cast into `false'.

\section{Functions}

Functions are defined as follows:

\begin{verbatim}
function foo(a, b)
    return a + b;
end;
\end{verbatim}

This places the value \verb|foo| on the heap of the current \hyperref[sec:function-call-stack]{stack frame}, with a value of type Function. This value points to the FunctionDefinition AST node of the defined function. In sttp this value will be treated as a String in the format: \verb|function:JSON_PATH:SAFE_PTR|.

\subsection{Call Stack}
\label{sec:function-call-stack}

Each time a function is called, the Function value will be fetched using JSONPath. If the value returned by the JSONPath is not a Function type, then the builtin function table will be checked, if the function is still not found then an Uncallable error is thrown.

If the function call is to a user-defined function within the AST. The arguments that were provided to the function are evaluated. Then a new stack frame is allocated and placed on the top of the stack. This stack frame contains a pointer back to the FunctionCall AST node, as well as a pointer to the FunctionDefinition AST node which contains the name, body, and parameters of the function that was called.

If the function call is to a builtin or is a HTTP method call, then no stack frame is allocated. The corresponding Golang code is executed instead. At the beginning of each sttp program an initial stack frame is assigned which points to nil for both FunctionCall and FunctionDefinition pointers.

\subsection{Heap}

Along with these pointers a new heap is assigned. This contains a mapping of variable names to sttp values. All values defined as a global variable from the previous stack frame are copied over to the new stack stack frame. Each argument is assigned to the JSONPath defined in the function's parameters and placed on this heap. If there is no argument for a defined function parameter, then that parameter will be set to `null'. If there are more arguments provided then there are parameters, then a MoreArgsThanParams error is thrown. A `self' value is also placed on the heap which contains the value pointed to by the root property of the JSONPath of the function. This value is defined as global, the reason for which will be discussed later. For instance:

\begin{verbatim}
hello_world = {"name": "John Smith"};

function hello_world.hello()
    $print("Hello", self.name + "!");
end;

hello_world.hello();
// Output: Hello John Smith!
\end{verbatim}

Parameters are defined in order from left to right, with the `self' parameter defined first. This can give way to some interesting behaviour such as the following:

\begin{verbatim}
foo = {"name": "John Smith"};

// "foo" is populated with new keys "a", "b", and "c"
function foo.zoo(self.a, self.b, foo.c)
    self.result = self.a * self.b * self.c;
end;

foo.zoo(3, 7, 2);
print(foo);
// Output: {
//     "a": 3,
//     "b": 7,
//     "c": 2,
//     "name": "John Smith",
//     "result": 42,
//     "zoo": "function:foo.zoo:XXXXXXX"
// }
\end{verbatim}

Once the function has completed execution, then the values on the heap defined as globals in the current stack frame are copied over to the previous stack frame, this includes `self' (as it is global). If the value's variable name is `self', then the value will be assigned to the root property of the currently executing function's JSONPath. Finally, the current stack frame is popped from the callstack.

\section{Error handling}

Each evaluator for each node in the AST is able to return an error and a result. If an error occurs within a leaf node of the AST, then this error will be passed all the way up to the root of the AST, or up until a Try-Catch AST node.

\begin{center}
    The try catch statement works in the following way:
    \begin{verbatim}
        try this
            a = [1, 2, 3];
            // Error occurs on below line
            $print(a[-4]);
        catch as e then
            $print(e);
        end;
    \end{verbatim}
\end{center}

Definition of a variable to store the exception within is mandatory and has to be an identifier, rather than a JSONPath. The value stored within the identifier follows the rules defined below:

\begin{enumerate}
    \item If the error is from a \verb|throw| statement then the value placed into the identifier will match the value of the result of the expression in the \verb|throw| statement. If no expression is given for the \verb|throw| statement, then `null' will be stored in the identifier.
    \item If the error is \textbf{not} from a \verb|throw| statement then the value is constructed in the following way:
    \begin{center}
        \begin{verbatim}
    {
        "type":   The name/type of the error (string),
        "error":  The error message (string),
        "subset": The subset which the error is 
                  a part of (string)
    }
        \end{verbatim}
    \end{center}
\end{enumerate}

\subsection{Error types}

\subsubsection{Subset: Runtime}

\begin{center}
    \begin{tabular}{| m{5cm} | m{5cm} |}
        \hline
        Name & Description\\
        \hline
        StackOverflow & Pushed one too many stack frames onto the call stack. Default max stack size is 500.\\
        \hline
	    StackUnderFlow & Popped one too many stack frames off the call stack.\\
        \hline
	    CannotFindType & Cannot find the type for a value. If the value is not a JSON type.\\
        \hline
	    CannotCast & Cannot cast a value of type $x$ into a value of type $y$.\\
        \hline
	    CannotFindLength & Cannot find the length of a value.\\
        \hline
	    InvalidOperation & Operation $z$ between a value of type $x$ and a value of type $y$ is not defined.\\
        \hline
	    StringManipulationError & Error whilst manipulating a string using all string manipulation operators.\\
        \hline
	    JSONPathError & Cannot access a value with a property/part.\\
        \hline
	    Uncallable & Only values of the Function type can be called. Otherwise, this error is thrown.\\
        \hline
	    MoreArgsThanParams & More arguments were given to a function during a function call than there are defined parameters in the function's definition.\\
        \hline
	    MethodParamNotOptional & A parameter within a HTTP method call is not optional.\\
        \hline
    \end{tabular}
\end{center}

\subsubsection{Subset: Structure}

\section{Batching}

The \verb|batch| construct lets you \textbf{parallelise all HTTP method calls made within a block}. This is made possible using Golang's extensive parallelism support. Batching will be explained through the use of this example code snippet:

\begin{center}
    \begin{verbatim}
    01 batch this
    02     for url in [
    03         "https://a.com",
    04         "https://b.com",
    05         "https://c.com"
    06     ] do
    07         result = $GET(url);
    08         $print(result);
    09     end;
    10     oops_forgot_this = $GET("https://d.com");
    11     $print(oops_forgot_this);
    12 end;
    \end{verbatim}
\end{center}

A \verb|batch| block is \textbf{always evaluated twice}. This means that it is important to \textbf{keep all non-HTTP-method-call statements and expressions to a minimum} as these will only slow down the interpreter.

Before the first pass begins, the contents of the variables in memory are deep copied so that they can be reverted to after the first pass. In the first pass the interpreter enqueues every single HTTP method call as a job within a work queue. Each job has a unique ID and the order of this work queue is saved (more on this later). In the example the HTTP method on line 7 will be added to the work queue 3 separate times with different arguments. Whereas, the HTTP method on line 10 is only enqueued once.

After this, the jobs in the work queue are executed using a pool of threads. The result of each job is added to a queue along with the executed job's ID. The result queue is then sorted back into the same order in which their respective jobs were added to the work queue. For instance, the result queue of the example above might look like this:

\begin{center}
    \begin{verbatim}
                Head -> "Response from 'a'" ->
                        "Response from 'b'" ->
                        "Response from 'c'" ->
                        "Response from 'd'"
    \end{verbatim}
\end{center}

Then, the contents of the variables in memory are set back to what they were before the first pass and the second pass is initiated. In the second pass, each time a HTTP method call is stepped into the next result in the result queue is dequeued and used.

\subsection{Caveats}

\subsubsection{Be sensible.}

A \verb|batch| block will offer no performance boosts if the block contains long running code with sparse usage of HTTP method calls, and could very well be \textbf{detrimental} to the performance of your code. Some general tips...

\begin{itemize}
    \item \textbf{Don't surround long running for or while loops in a batch statement.}
    \item \textbf{Keep expressions and statements without HTTP method calls down to a minimum.}
    \item \textbf{If you are only making a few HTTP method calls rather than 10s or 100s then it might be more performant to remove the batch block.}
\end{itemize}

It is also worth noting that if there is a \verb|batch| block containing \textbf{zero HTTP method calls}, then the interpreter will \textbf{silently skip the second pass}. There is no need to batch what cannot be batched.

\subsubsection{You cannot batch what has already been batched}

You cannot use a \verb|batch| block within a \verb|batch| block. Your program will throw an uncatchable error. This will be thrown after parsing in a special AST checking procedure before evaluation is started.

\subsubsection{Method calls within function calls are not batched}

HTTP method calls made within functions are not batched for the simple fact that a function could already contain another \verb|batch| block. This is undefined behavior (see above). However, \verb|batch| statements can still be used inside function definitions if functional-abstraction is necessary/nice.

\subsubsection{Try-catch surrounding batch blocks}

If an exception occurs in the first or second pass and there is a try-catch surrounding the batch block, then the batch block will be canceled from that point onwards.

If the exception occurs in the thread execution phase then the exception is thrown after all requests are made. If multiple exceptions occur they will be wrapped into one exception in the form of an object.

% \begin{center}
%     \begin{verbatim}
%         chunk ::= block
%         block ::= {stat} [retstat]
%         stat ::=  ‘;’ | 
%              varlist ‘=’ explist | 
%              functioncall | 
%              label | 
%              break | 
%              goto Name | 
%              do block end | 
%              while exp do block end | 
%              repeat block until exp | 
%              if exp then block {elseif exp then block} [else block] end | 
%              for Name ‘=’ exp ‘,’ exp [‘,’ exp] do block end | 
%              for namelist in explist do block end | 
%              function funcname funcbody | 
%              local function Name funcbody | 
%              local attnamelist [‘=’ explist] 
%         attnamelist ::=  Name attrib {‘,’ Name attrib}
%         attrib ::= [‘<’ Name ‘>’]
%         retstat ::= return [explist] [‘;’]
%         label ::= ‘::’ Name ‘::’
%         funcname ::= Name {‘.’ Name} [‘:’ Name]
%         varlist ::= var {‘,’ var}
%         var ::=  Name | prefixexp ‘[’ exp ‘]’ | prefixexp ‘.’ Name 
%         namelist ::= Name {‘,’ Name}
%         explist ::= exp {‘,’ exp}
%         exp ::=  nil | false | true | Numeral | LiteralString | ‘...’ |
%              functiondef | prefixexp | tableconstructor | exp binop exp |
%              unop exp 
%         prefixexp ::= var | functioncall | ‘(’ exp ‘)’
%         functioncall ::=  prefixexp args | prefixexp ‘:’ Name args 
%         args ::=  ‘(’ [explist] ‘)’ | tableconstructor | LiteralString 
%         functiondef ::= function funcbody
%         funcbody ::= ‘(’ [parlist] ‘)’ block end
%         parlist ::= namelist [‘,’ ‘...’] | ‘...’
%         tableconstructor ::= ‘{’ [fieldlist] ‘}’
%         fieldlist ::= field {fieldsep field} [fieldsep]
%         field ::= ‘[’ exp ‘]’ ‘=’ exp | Name ‘=’ exp | exp
%         fieldsep ::= ‘,’ | ‘;’
%         binop ::=  ‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘//’ | ‘^’ | ‘%’ | 
%              ‘&’ | ‘~’ | ‘|’ | ‘>>’ | ‘<<’ | ‘..’ | 
%              ‘<’ | ‘<=’ | ‘>’ | ‘>=’ | ‘==’ | ‘~=’ | 
%              and | or
%         unop ::= ‘-’ | not | ‘#’ | ‘~’
%     \end{verbatim}
% \end{center}

% Program  -> Block.
% Block    -> Stmt | Stmt RetStmt.
% Stmts    -> Stmt Stmt |.
% Stmt     -> semi |
%     JSONPath equal Exp |
%     FuncCall |
%     MethodCall |
%     Break |
%     While Exp Do Block End |
%     For Ident equal Exp semi Exp Do Block End |
%     For Ident equal Exp semi Exp semi Exp Do Block End |
%     For Ident In Exp Do Block End |
%     For Ident comma Ident In Exp Do Block End |
%     Function JSONPath FuncBody |
%     If Exp Then Block Elifs End |
%     If Exp Then Block Elifs Else Block End.
% Elifs    -> Elif Exp Then Block Elifs |.
% JSONPath -> Part Parts.
% Parts    -> dot Part Parts |.
% Part     -> Ident Indices.
% Indices  -> sqrL Exp sqrR Indices|.
% RetStmt  -> Return |
%             Return semi |
%             Return Exp semi |
%             Return Exp.
% FuncCall -> JSONPath Args.
% MethodCall -> Method Args.
% FuncBody -> parenL Params parenR Block End | parenL parenR Block End.
% Params   -> Ident Idents.
% Idents   -> comma Ident Idents |.
% Args     -> parenL ExpList parenR | parenL parenR.
% ExpList  -> Exp Exps.
% Exps     -> comma Exp Exps |.

% Exp      -> Prec5T Precs5.
% Precs5   -> Prec5 Precs5|.
% Prec5    -> Prec5Op Prec5T Prec5.
% Prec5Op  -> union.

% Prec5T   -> Prec4T Precs4.
% Precs4   -> Prec4 Precs4|.
% Prec4    -> Prec4Op Prec4T Prec4.
% Prec4Op  -> and.

% Prec4T   -> Prec3T Precs3.
% Precs3   -> Prec3 Precs3|.
% Prec3    -> Prec3Op Prec3T Prec3.
% Prec3Op  -> eq | ne.

% Prec3T   -> Prec2T Precs2.
% Precs2   -> Prec2 Precs2|.
% Prec2    -> Prec2Op Prec2T Prec2.
% Prec2Op  -> lt | gt | lte | gte.

% Prec2T   -> Prec1T Precs1.
% Precs1   -> Prec1 Precs1|.
% Prec1    -> Prec1Op Prec1T Prec1.
% Prec1Op  -> plus | minus.

% Prec1T   -> Factor Precs0.
% Precs0   -> Prec0 Precs0|.
% Prec0    -> Prec0Op Factor Prec0.
% Prec0Op  -> mult | div.

% Factor   -> Null |
%             False |
%             True |
%             Number |
%             StringLit |
%             JSONPath |
%             JSON |
%             FuncCall | MethodCall |
%             AriExp |
%             parenL Exp parenR.

% JSON     -> Object | Array.
% Object   -> curlyL Members curlyR | curlyL curlyR.
% Members  -> Pair Pairs.
% Pairs    -> comma Pair Pairs |.
% Pair     -> Exp colon Exp.
% Array    -> sqrL ExpList sqrR.

\end{document}